#++++ install source file:  /home/sgm/spec/macros/README.mac
#  @(#)README.mac	6.1  07/29/12 CSS
#
# Please do not edit the standard CSS macro files.  When spec is
# updated or reinstalled, all such changes will get clobbered.  If
# you need to change the standard macros, place the modified
# macros in one of the following files, as appropriate.
#
#      SPECD/site_f.mac        (read only when starting fresh)
#      SPECD/site.mac          (read each time each user starts)
#      SPECD/fourc/conf.mac    (or sixc, spec, kappa, etc.)
#      ./spec.mac              (relative to start up directory)
#
# None of these files are created by the spec installation.  They
# are locally created and maintained files.  Each file, if it exists,
# is read in the order listed above, after the standard CSS macro
# files are read.  Macros definitions in the above files will replace any
# macros of the same name that were read from the standard CSS macro
# files.
#
# If you do need to change a standard macro for your site, please
# contact CSS so that, if practical, future versions of the standard
# macros will be redesigned to accommodate your needs.
#
#++++ install source file:  /home/sgm/spec/macros/util.mac
#
#  @(#)util.mac	6.5  04/14/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2005,2012,2013
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################
#
# Utility macros
#
global  _1 _2 _3 _4 _5 _6 _7 _8 _9  # used to hold arguments in many macros
global  DATAFILE DOFILE DO_DIR

def u     'unix("$*")'          # Create a subshell
def ned   'unix("ned $*")'
def vi    'unix("vi $*")'
def emacs 'unix("emacs $*")'
def ed    'unix("ed $*")'
def cat   'unix("cat $*")'
def l     'unix("ls -l $*")'
def ls    'unix("ls $*")'
def less  'unix("less $*")'
def more  'unix("more $*")'
def mail  'unix(sprintf("%s $*",MAIL))'
def pwd   'print CWD'
def d     'print date()'        # Print current time and date
def cd    'chdir("$*")'         # Change current working directory
def com   'comment "$*"'        # Shorthand for comment
def p     'print'               # Shorthand for print
def hi    'history'             # Shorthand for history
def h     'help'                # Shorthand for help
def chelp 'help'                # To be consistant with shell command
def cl    'tty_cntl("cl")'      # Clear the screen
def beep  'printf("\a")'        # Use \a for alert (beep)
def formfeed 'printf("\f")'

# PRINTER has been deprecated.  Provide null definitions so old macros don't break
def ifp   'if (0)'
def onp   ''
def offp  ''

def ifd   'if (DATAFILE != "" && DATAFILE != "/dev/null")'
def ond   'if (DATAFILE != "") { on(DATAFILE); };'
def offd  'if (DATAFILE != "") { off(DATAFILE); };'
def ont   'on("tty")'
def offt  'off("tty")'
def fon  'if ($# == 1) on("$1"); else { eprint "Usage: fon file\n";on()}'
def foff 'if ($# == 1) off("$1"); else { eprint "Usage: foff file\n";on()}'
def fclose 'if ($# == 1) close("$1"); else { eprint "Usage: fclose file\n";on()}'
def waitall     '{
		   user_waitall; wait(0)
		   WAITING_MOVE = WAITING_COUNT = WAITING_ACQ = 0
		}'
def waitmove    '{ user_waitmove; wait(1); WAITING_MOVE = 0 }'
def waitcount   '{ user_waitcount; wait(2); WAITING_COUNT = 0 }'
def waitacq     '{ user_waitacq; wait(4); WAITING_ACQ = 0 }'
#def chk_move    '((WAITING_MOVE = wait(0x21)) || USER_CHK_MOVE)'
def chk_move    '((WAITING_MOVE = wait(0x21)) || (USER_CHK_MOVE = user_chkmove()))'
def chk_count   '((WAITING_COUNT = wait(0x22)) || USER_CHK_COUNT)'
def chk_acq     '((WAITING_ACQ = wait(0x24)) || USER_CHK_ACQ)'
def w           '{ waitall; beep }'
def user_waitall ''
def user_waitmove ''
def user_waitcount ''
def user_waitacq ''

global  WAITING_MOVE            # result of most recent wait(0x21)
global  WAITING_COUNT           # result of most recent wait(0x22)
global  WAITING_ACQ             # result of most recent wait(0x24)

global  USER_CHK_MOVE           # Used in chk_move above
global  USER_CHK_COUNT          # Used in chk_count above
global  USER_CHK_ACQ            # Used in chk_acq above

# Examine help file, use default if no argument
def help  '
	if ($#)
		gethelp("$1");
	else {
		local t
		for (t="help";;)
			if (gethelp(t) || (t = input("\nSubject?  ")) == "")
				break
	}
'

# Have output of any command sent to a file
def savcmd '
	if ($# != 2) {
		eprint "Usage:  savcmd command filename"
		exit
	}
	fprintf("$2","\n$1\n");on("$2");$1
	close("$2")
'

# Prompts user to set a variable
def getvar '{
	$2 = getval("$1", $2)
}'

# Test if a symbol has been assigned a value, yet
def unset(x) '{ return(whatis(x)&0x8000000? 1:0) }'
def is_macro(x) '{ return(whatis(x)&2? 1:0) }'

# Easier way to set debug level ($* is nothing during macro substitution)
def debug '{
	local t
	if ($# == 0) {
		print "
Add values together to obtain a debugging level:

    1     0x1  Show input tokens during parsing.
    2     0x2  Show node execution while running.
    4     0x4  Show node allocate and free.
    8     0x8  Show symbol table creation and lookup.
   16    0x10  Show value get and set.
   32    0x20  Show misc memory-related info.
   64    0x40  Show hardware related info.
  128    0x80  Show more hardware related info.
  256   0x100  Show macro substitution.
  512   0x200  Show memory allocate and free.
 1024   0x400  Show input after macro expansion.
 2048   0x800  Print warning messages.
 4096  0x1000  Show certain low level hardware info.
 8192  0x2000  Show data array allocation.
 ...   0x4000  Show signal blocking.
 ..    0x8000  Show low level hardware info.
 .    0x10000  Show input file queuing.
 .    0x20000  Show readable runtime debugging.
 .    0x40000  Print input context on execution-time errors.
 .    0x80000  Show sleeps.
 .   0x100000  Show thread stuff.
 .   0x200000  Show state changes.
 .   0x400000  Use hexadecimal for socket debugging output.
 .   0x800000  Show server/client socket messages."
		t = input(sprintf("\nDebug value (0x%x)? ", DEBUG))
	} else
		t = "$*"
	if (index(t, "+"))
		DEBUG |= 0+t
	else if (index(t, "-"))
		DEBUG &= ~(0-t)
	else
		DEBUG = 0+t
}'

# edit and re-read configuration file

global  EDCONF_BOX_FLAG

def user_config ''
def config '
	wait(-1)
	user_waitall
	sync
	unix(sprintf("%s/edconf %s %s %s/%s",\
	  SPECD, set_sim(-1)? "-s":"", EDCONF_BOX_FLAG? "-b":"", SPECD, SPEC))
	reconfig
	user_config
	_assign
	_assign_mono
'

##  wizard macros more-or-less from ESRF
# With no args, onwiz activates wizard mode for 10 minutes.
# With a positive arg, timer is set for arg seconds.
# With a negative arg, wizard mode stays on.
# With arg=0, can use in a macro for wiz mode for duration of macro.
# It will be turned off on first instance of prompt_mac.
# If wiz mode already active, an arg can change the timer.
def onwiz '{
    local is_on; is_on = spec_par("specwiz")

    if ((!is_on || $1) && (is_on || spec_par("specwiz",1))) {
	local timeout; timeout = $#? $1:600
	if (timeout >= 0) {
	    global WIZ_TIME; WIZ_TIME = time() + timeout
	    cdef("prompt_mac",\
	    \'if (time()>WIZ_TIME) {cdef("","","onwiz","delete");offwiz}\n\',\
		"onwiz")
	} else
	    cdef("", "", "onwiz", "delete")
    }
}'

#  Deactivates wizard mode.
def offwiz 'spec_par("specwiz",0);unglobal WIZ_TIME'


global  MAIL
if (MAIL == "")
	MAIL="mail"

global  ADMIN
if (ADMIN == "")
	ADMIN="specadm"

# mail a bug report to the administrator
def bug '
	printf("The mail utility will be run for you.  Describe your\n")
	printf("problem to the administrator.  When you are done, type ^D.\n")
	{
	local s
	s = unix(sprintf("%s -s \"Bug from %s\" %s", MAIL, USER, ADMIN))
	printf("Bug report %ssent to %s.\n", s? "not ":"", ADMIN)
	}
'

# A macro function for comments can be more efficient
def fcom(s) '{
	local f

	f = sprintf("%s.  %s.\n", date(), s)
	printf("\n%s", f)
	if (DATAFILE != "" && DATAFILE != "/dev/null")
		fprintf(DATAFILE, "#C %s", f)
}'
# As above, but doesn't write to screen
def fcom_quiet(s) '{
	local f

	f = sprintf("%s.  %s.\n", date(), s)
	if (DATAFILE != "" && DATAFILE != "/dev/null")
		fprintf(DATAFILE, "#C %s", f)
}'

# Print a comment on the screen and data file
def comment '
	printf("\n%s.  $1.\n", date(), $2)
	qcomment "$1" "$2"
'
# Print a comment on the printer and data file
def qcomment '
	if (DATAFILE != "")
		fprintf(DATAFILE,"#C %s.  $1.\n", date(), $2)
	#
'
# Set something and comment if it has changed.
def gpset '{
	if ($1 != $2) {
		fcom_quiet(sprintf("$2 reset from %g to %g",$2,$1))
		$2 = $1
	}
	#
}'
cdef("user_onsim")
cdef("user_offsim")

# Turn simulate mode on
def onsim '{
	local   t

	if (!(t = set_sim(1))) { qcomment "Simulate mode ON" }
	user_onsim
	printf("Simulate was %s, is now %s.\n", t? "on":"off",\
				       set_sim(-1)? "ON":"OFF")
}'
# Turn simulate mode off
def offsim '{
	local   t

	if (t = set_sim(0)) { qcomment "Simulate mode OFF" }
	printf("Simulate was %s, is now %s.\n", t? "on":"off",\
				       set_sim(-1)? "ON":"OFF")
	user_offsim
}'
# "do" a command file
def do  '_do do $*'
# quietly "do" a command file
def qdo '_do qdo $*'
# run a command file
def _do '{
	local narg, cmd, file, label

	label = 0
	narg = sscanf("$*", "%s %s %[^\n]", cmd, file, label)

	if (narg < 2  || cmd != "do" && cmd != "qdo") {
		eprint "Usage:  do file [ line | label ]"
		eprint "       qdo file [ line | label ]"
		exit
	}

	if (file == "." && DOFILE == "") {
		eprint "No previous \"do\" file."
		exit
	}
	if (file != ".") {
		DOFILE = file
		if (DO_DIR != "" && !file_info(DOFILE, "-r")) {
			local t, i, n, dirs[]

			n = split(DO_DIR, dirs, ":")
			for (i = 0; i < n; i++) {
			    if (dirs[i] && file_info(t = dirs[i] "/" DOFILE, "-r")) {
				    DOFILE = t
				    break
			    }
			}
		}
	}
	if (file_info(DOFILE, "-r")) {
		qcomment "do %s" DOFILE
		if (cmd == "do")
			dofile(DOFILE, label)
		else
			qdofile(DOFILE, label)
	} else {
		eprintf("Can\'t read command file \"%s\".\n", DOFILE)
		exit
	}
}'
# Reread standard macro files
def newmac '{
	local t

	if (file_info(t = sprintf("%s/%s/conf.mac", SPECD,SPEC), "-f")) {
		qcomment "do %s" t
		qdofile(t)
	}
	if (file_info(t = SPECD "/site.mac", "-f")) {
		qcomment "do %s" t
		qdofile(t)
	}
	if (file_info(t = SPECD "/site_f.mac", "-f")) {
		qcomment "do %s" t
		qdofile(t)
	}
	if (file_info(t = sprintf("%s/%s/%.4s.mac", SPECD,SPEC,SPEC), "-f")) {
		qcomment "do %s" t
		qdofile(t)
	}
	t = sprintf("%s/%.4s.mac", SPECD, SPEC)
	qcomment "do %s" t
	qdofile(t)
	t = SPECD "/standard.mac"
	qcomment "do %s" t
	qdofile(t)
}'
# Save a macro definition to a file
def savmac '
	if ($# != 2) {
		eprint "Usage:  savmac macro_name filename"
		exit
	} 
	on("$2"); offt
	prdef $1
	ont; close("$2")
'
# Try to figure out what kind of thing a symbol is
def whats '
	if ($# != 1) {
		eprint "Usage:  whats whatever"
		exit
	}
	print whatis(\'$1\', 1)
'
# Sleep for a while, displaying the time left
def do_sleep '{
	local i, j
	if ((i=j=$1) > 2) {
		for (;i>= 1; i -= 1) {
			printf("\rSleeping %d",i)
			tty_cntl("ce")
			printf("\r")
			sleep(1)
		}
		if (i > 0)
			sleep(i)
		if (j > 2) {
			tty_cntl("ce")
			printf("\r")
		}
	} else
		sleep($1)

}'
# Save current globals to a save file
def save '{
	local f

	if ($# == 0)
		f = getsval("File for saving globals", "saved")
	else if ($# == 1)
		f = "$1"
	else {
		eprint "Usage:  save [filename]"
		exit
	}
	if (file_info(f, "-s"))
		unix(sprintf("mv %s %s.bak", f, f))
	on(f); offt
	savegeo
	saveusr
	ont; close(f)
	qcomment "Globals saved in \"%s\"" "f"
	printf("Type \"do %s\" to recover.\n", f)
}'
# redefined by user to save what user wants to save
def saveusr ''

# If we have a modern version of less installed, use it for help
# file pager.  Not sure where the version cutoff is, but 332 seems
# to be safe.  The long prompt string is actually the default, except
# for the %s at the beginning of the -PM option, which spec uses to
# insert the name of the help file being displayed.
#
# -~ suppresses tildes on releases >= 335
# -w suppresses tildes on blank lines in pre-335 release
# -w highlights first line after scroll in release >= 335

if (unset("PAGER") || PAGER == "") {
  local s, v

  unix("less -V 2>&1", s)
  if (sscanf(s, "%*[ a-zA-Z]%d", v) == 1 && v >= 332) {
     if (v > 337)
	PAGER="less -~ -X -e -c -mM -PM'%s ..?ltline %%lt?L/%%L. \
:byte %%bB?s/%%s. .?e(END) :?pB%%pB\%%..%%t$'"
     else
	PAGER="less -w -X -e -c -mM -PM'%s ..?ltline %%lt?L/%%L. \
:byte %%bB?s/%%s. .?e(END) :?pB%%pB\%%..%%t$'"
  }
}

# If you are using macros from 4.05.x or beyond with an older spec
# version, make the following definitions:
#  rdef eprint 'print'
#  rdef eprintf 'printf'

#++++ install source file:  /home/sgm/spec/macros/scans.mac
#
#  @(#)scans.mac	6.8  04/04/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-1993,1997,1998,1999,2004,2012,2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#########################################################################
#
#                        BASIC SCANS
#
#########################################################################
#
# `ascan' is a single-motor scan
#
def ascan '
	if ($# != 5) {
		eprint "Usage:  ascan  motor start finish  intervals time"
		exit
	} 
	_check0 "$1"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_n1 = int($4); _ctime = $5
	_nm = 1
	_ascan
'
#########################################################################
#
# `a2scan' is a two-motor scan
#
def a2scan '
	if ($# != 8) {
		eprint "\
Usage:  a2scan  motor1 s1 f1  motor2 s2 f2  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_n1 = int($7); _ctime = $8
	_nm = 2
	_ascan
'
#########################################################################
#
# `a3scan' is a three-motor scan
#
def a3scan '
	if ($# != 11) {
		eprint "\
Usage:  a3scan  motor1 s1 f1  motor2 s2 f2  motor3 s3 f3  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_n1 = int($10); _ctime = $11
	_nm = 3
	_ascan
'
#########################################################################
#
# `a4scan' is a four-motor scan
#
def a4scan '
	if ($# != 14) {
		eprint "\
Usage:  a4scan  m1 s1 f1  m2 s2 f2  m3 s3 f3  m4 s4 f4  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"; _check0 "$10"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_m[3] = $10; _s[3] = $11; _f[3] = $12
	_n1 = int($13); _ctime = $14
	_nm = 4
	_ascan
'
#########################################################################
#
# `a5scan' is a five-motor scan
#
def a5scan '
	if ($# != 17) {
		eprint "\
Usage:  a5scan  m1 s1 f1 m2 s2 f2 m3 s3 f3 m4 s4 f4 m5 s5 f5  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"; _check0 "$10"; _check0 "$13"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_m[3] = $10; _s[3] = $11; _f[3] = $12
	_m[4] = $13; _s[4] = $14; _f[4] = $15
	_n1 = int($16); _ctime = $17
	_nm = 5
	_ascan
'
#########################################################################
#
# `mesh' is a two-motor nested scan
#
def mesh '
	if ($# != 9) {
		eprint "\
Usage:  mesh  mot1 s1 f1 intervals1  mot2 s2 f2 intervals2  time"
		exit
	} 
	_check0 "$1"; _check0 "$5"
	{
		_m[0] = $1; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m[1] = $5; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_bad_lim = 0
	_chk_lim _m[0] _s1
	_chk_lim _m[0] _f1
	_chk_lim _m[1] _s2
	_chk_lim _m[1] _f2
	if (_bad_lim) exit

	HEADING = sprintf("mesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2, $3, $4, $6, $7, $8, $9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	_nm=2
	_cols=2+_hkl_col
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = scanType_MotorScan|scanType_MeshScan|(2<<8)
	FPRNT=sprintf("%s  %s  ",motor_name(_m[0]),motor_name(_m[1]))
	VPRNT=sprintf("%9.9s %9.9s ",motor_name(_m[0]),motor_name(_m[1]))
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	VFMT=sprintf("%%9.%df %%9.%df ",UP,UP)
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 for (; _g2 < _n2; _g2++){
		if (_g1 == _n1) {
			_g1 = 0
			if (_g2)
				print
		}
		for (; _g1 < _n1; _g1++, NPTS++) {
			A[_m[0]] = _s1 + _g1 * _d1
			A[_m[1]] = _s2 + _g2 * _d2
			scan_move
			FPRNT=sprintf("%.8g %.8g ",A[_m[0]],A[_m[1]])
			VPRNT=sprintf(VFMT,A[_m[0]],A[_m[1]])
			FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
			scan_loop
			scan_data(_g1,A[_m[0]])
			scan_plot
		}
	 }
	 scan_tail
	\'
	_scan_on
'

#########################################################################
#
# `hklscan' is a general linear reciprocal space scan
# (Limit checking is done at the last point first, since limits
# are often exceeded at the extreme points of a scan.)
def hklscan '
	if ($# != 8) {
		eprint "\
Usage:  hklscan Hstart Hfinish Kstart Kfinish Lstart Lfinish intervals time"
		exit
	} 
	{
		_s1 = $1; _f1 = $2; _s2 = $3; _f2 = $4; _s3 = $5; _f3 = $6
		_n1 = int($7); _ctime = $8
	}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 
	HEADING = sprintf("hklscan  %g %g  %g %g  %g %g  %g %g", $1,$2,$3,\
		$4,$5,$6,$7,$8)
	_d1 = (_f1 - _s1)/_n1
	_d2 = (_f2 - _s2)/_n1
	_d3 = (_f3 - _s3)/_n1++

	H=_f1; K=_f2; L=_f3
	calcA; _bad_lim=0; _hkl_lim
	if (_bad_lim) {
		eprintf("(H K L = %g %g %g)\n",H,K,L)
		exit
	}
	if (_pre_chk) {
		local i
		for (i=0;i<_n1;i++) {
			H = _s1 + i*_d1
			K = _s2 + i*_d2
			L = _s3 + i*_d3
			calcA
			_bad_lim = 0
			_hkl_lim
			if (_bad_lim) {
				eprintf("(H K L = %g %g %g)\n",H,K,L)
				exit
			}
		}
	}
	_cols=3
	if (_sav_geo_mot)
		_cols += _numgeo
	if (_d3)
		{ X_L = "L"; _sx = _s3; _fx = _f3 }
	else if (_d2)
		{ X_L = "K"; _sx = _s2; _fx = _f2 }
	else
		{ X_L = "H"; _sx = _s1; _fx = _f1 }
	Y_L = cnt_name(DET)
	_stype = scanType_HKL_Scan
	FPRNT="H  K  L  "
	if (_sav_geo_mot) {
		local i
		for (i=0;i<_numgeo;i++)
		       FPRNT = FPRNT motor_name(mA[i]) "  "
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i h_ca k_ca l_ca
		H = h_ca = _s1 + NPTS*_d1
		K = k_ca = _s2 + NPTS*_d2
		L = l_ca = _s3 + NPTS*_d3
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g ",h_ca,k_ca,l_ca)
		if (_sav_geo_mot)
			for (i=0;i<_numgeo;i++)
				FPRNT = FPRNT sprintf("%.8g ",A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_d3? l_ca:(_d2? k_ca:h_ca))
		H=h_ca; K=k_ca; L=l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
#########################################################################
#
# `hklmesh' is a two-Q nested scan.  It uses the fact that H, K and L
# are defined as Q[0], Q[1] and Q[2], respectively.
#
def hklmesh '
	_m1 = index("HKL", "$1")
	_m2 = index("HKL", "$5")
	if ($# != 9 || !_m1 || !_m2 || _m1 == _m2) {
		eprint "\
Usage:  hklmesh  Q1 s1 f1 intervals1  Q2 s2 f2 intervals2  time\n\
	Q1 and Q2 are H, K or L.  Q1 != Q2"
		exit
	}
	waitall; get_angles; calcHKL
	{
		_m1--; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m2--; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	}

	HEADING = sprintf("hklmesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2,$3,$4,$6,$7,$8,$9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	if (_pre_chk) {
		local i j
		for (i=0; i<_n2; i++) {
			Q[_m2] = _s2 + i * _d2
			for (j=0; j<_n1; j++) {
				Q[_m1] = _s1 + j * _d1
				calcA
				_bad_lim = 0
				_hkl_lim
				if (_bad_lim) {
					eprintf("(H K L = %g %g %g)\n", H,K,L)
					exit
				}
				calcHKL
			}
		}
	}
	_cols=3
	if (_sav_geo_mot)
		_cols += _numgeo
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = scanType_HKL_Scan|scanType_MeshScan
	FPRNT="H  K  L  "
	if (_sav_geo_mot) {
		local i
		for (i=0;i<_numgeo;i++)
			FPRNT = FPRNT motor_name(mA[i]) "  "
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	_hklmesh
'
# Long macro definition requires 2 parts
#  save Q[_m3] at start of mesh and restore at each point to prevent drift
def _hklmesh '
	_m3 = 3 - _m1 - _m2
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 {
	  local _ca
	  _ca[_m3] = Q[_m3]
	  for (; _g2 < _n2; _g2++){
		Q[_m2] = _ca[_m2] = _s2 + _g2 * _d2
		if (_g1 == _n1)
			_g1 = 0
		for (; _g1 < _n1; _g1++, NPTS++) {
			local i
			Q[_m1] = _ca[_m1] = _s1 + _g1 * _d1
			Q[_m3] = _ca[_m3]
			get_angles; calcA
			scan_move
			FPRNT=sprintf("%g %g %g ", _ca[0],_ca[1],_ca[2])
			if (_sav_geo_mot)
				for (i=0;i<_numgeo;i++)
					FPRNT = FPRNT sprintf("%.8g ",A[mA[i]])
			VPRNT=sprintf("%10.5g %10.5g %10.5g ", _ca[0],_ca[1],_ca[2])
			scan_loop
			scan_data(_g1,_ca[_m1])
			scan_plot
		}
	  }
	 }
	 scan_tail
	\'
	_scan_on
'


#########################################################################
#
# `hkcircle', `hlcircle', `klcircle', `hkradial', `hlradial', `klradial'
#  (with `_hklline') do circle and radial cuts in HKL space
#
# Circular scan in the H-K plane
def hkcircle '
	if ($# < 5) {
		eprint "\
Usage:  hkcircle radius angle_start angle_finish intervals time [L=expr]\n\
	(i.e. L=H/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = _const * sin(rad(\$1))
		K = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("hkcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Circular scan in the H-L plane
def hlcircle '
	if ($# < 5) {
		eprint "\
Usage:  hlcircle radius angle_start angle_finish intervals time [K=expr]\n\
	(i.e. K=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = _const * sin(rad(\$1))
		L = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("hlcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Circular scan in the K-L plane
def klcircle '
	if ($# < 5) {
		eprint "\
Usage:  klcircle radius angle_start angle_finish intervals time [H=expr]\n\
	(i.e. H=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		K = _const * sin(rad(\$1))
		L = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("klcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the H-K plane
def hkradial '
	if ($# < 5) {
		eprint "\
Usage:  hkradial angle start finish intervals time [L=expression]\n\
	(i.e.  L=H/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = \$1 * sin(rad(_const))
		K = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("hkradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the H-L plane
def hlradial'
	if ($# < 5) {
		eprint "\
Usage:  hlradial angle start finish intervals time [K=expression]\n\
	(i.e. K=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = \$1 * sin(rad(_const))
		L = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("hlradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the K-L plane
def klradial '
	if ($# < 5) {
		print "\
Usage:  klradial angle start finish intervals time [H=expression]\n\
	(i.e. H=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		K = \$1 * sin(rad(_const))
		L = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("klradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
def _hklline '
	{_const = $1; _s1 = $2; _f1 = $3; _n1 = int($4); _ctime = $5}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_d1 = (_f1 - _s1) / _n1++
	_cols=4
	if (_sav_geo_mot)
		_cols += _numgeo
	_sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = scanType_HKL_Scan
	FPRNT=sprintf("%s  H  K  L  ",X_L)
	if (_sav_geo_mot) {
		local i
		for (i=0;i<_numgeo;i++)
		       FPRNT = FPRNT motor_name(mA[i]) "  "
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")

	{
		local x
		x = _f1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}
	if (_pre_chk) for (i=0; i<_n1; i++) {
		local x
		x = _s1 + i * _d1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}

	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i x h_ca k_ca l_ca
		_x = _s1 + NPTS * _d1
		_hkl _x
		if ("$6" != "0")
			$6
		h_ca = H; k_ca = K; l_ca = L
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g %g ",_x,h_ca,k_ca,l_ca)
		if (_sav_geo_mot)
			for (i=0;i<_numgeo;i++)
				FPRNT = FPRNT sprintf("%.8g ",A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_x)
		H = h_ca; K = k_ca; L = l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
#########################################################################
#
# `tscan' is a temperature scan.  "scan_move" is included in loop for
#  powder mode to rock motors during a tscan.
#
def tscan '
	if ($# < 4) {
		eprint "Usage:  tscan start finish intervals time [sleep]"
		exit
	} 
	{ _s1 = $1; _f1 = $2; _n1 = int($3); _ctime = $4; _stime = $5; }

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	HEADING = sprintf("tscan %g %g %g %g %g", $1, $2, $3, $4, $5)
	_d1 = (_f1 - _s1) / _n1++
	_cols=1
	_sx = _s1; _fx = _f1
	X_L = "Measured"
	Y_L = cnt_name(DET)
	_stype = scanType_TempScan
	FPRNT="Setpoint  "
	VPRNT=sprintf("%9.9s %9.9s ", "Setpoint", "DegC")
	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		settemp _s1+NPTS*_d1
		do_sleep _stime
		scan_move
		FPRNT=sprintf("%g ",TEMP_SP)
		VPRNT=sprintf("%9.4f %9.4f ",TEMP_SP,DEGC_SP)
		scan_loop
		scan_data(NPTS, DEGC)
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'

#########################################################################
#
# The following scans are defined in terms of the more basic scans
# above.
#

# The cleanup macro for delta scans returns the motor(s) to the
# starting position(s).

def dscan_cleanup '{
	local   i, m[], n, mne

	n = split("$*", m)

	# following kludge until we get an eval() function
	if (n >= 2)  m[1] = $2
	if (n >= 4)  m[3] = $4
	if (n >= 6)  m[5] = $6
	if (n >= 8)  m[7] = $8
	if (n >= 10) m[9] = $10

	printf("\n")
	waitmove
	get_angles
	for (i = 0; i < n; i += 2) {
		mne = motor_mne(motor_num(m[i]))
		printf("Returning %s to %g\n", mne, m[i+1])
		A[motor_num(m[i])] = m[i+1]
	}
	_move
	printf("\n")
}'

# delta angle scan (ascan relative to current position)
def lup '
	if ($# != 5) {
		eprint "Usage:  lup motor start finish intervals time"
		exit
	} 
	dscan $*
'
def dscan '
	if ($# != 5) {
		eprint "Usage:  dscan motor start finish intervals time"
		exit
	} 
	_check0 "$1"
	waitall
	get_angles
	_c1=A[$1]

	cdef("cleanup_once", sprintf("dscan_cleanup $1 %s;", _c1), "dscan")

	ascan $1 _c1+($2) _c1+($3) $4 $5

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1
'
# Two motor dscan
def d2scan '
	if ($# != 8) {
		eprint "\
Usage:  d2scan  motor1 start1 finish1  motor2 start2 finish2  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]

	cdef("cleanup_once",\
		    sprintf("dscan_cleanup $1 %s $4 %s;", _c1, _c2), "dscan")

	a2scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) $7 $8

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2
'
# Three motor dscan
def d3scan '
	if ($# != 11) {
		eprint "\
Usage:  d3scan  motor1 start1 finish1  m2 s2 f2  m3 s3 f3  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4" ; _check0 "$7"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]
	_c3=A[$7]

	cdef("cleanup_once",\
	   sprintf("dscan_cleanup $1 %s $4 %s $7 %s;", _c1,_c2,_c3), "dscan")

	a3scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) \
				       $7 _c3+($8) _c3+($9) $10 $11

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2 $7 _c3
'
# Four motor dscan
def d4scan '
	if ($# != 14) {
		eprint "\
Usage:  d4scan  m1 s1 f1  m2 s2 f2  m3 s3 f3  m4 s4 f4  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4" ; _check0 "$7" ; _check0 "$10"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]
	_c3=A[$7]
	_c4=A[$10]

	cdef("cleanup_once",\
	 sprintf("dscan_cleanup $1 %s $4 %s $7 %s $10 %s;", _c1,_c2,_c3,_c4),\
	   "dscan")

	a4scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) \
		      "$7" _c3+($8) _c3+($9) "$10" _c4+($11) _c4+($12) $13 $14

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2 $7 _c3 $10 _c4
'
def th2th '
	if ($# != 4) {
	    eprint "Usage:  th2th tth_start_rel tth_finish_rel intervals time"
	    exit
	} 
	d2scan tth $1 $2 th ($1)/2 ($2)/2 $3 $4
'
# H scan
def hscan '
	if ($# != 4) {
		eprint "Usage:  hscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan $1 $2 K K L L $3 $4
'
# K scan
def kscan '
	if ($# != 4) {
		eprint "Usage:  kscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan H H $1 $2 L L $3 $4
'
# L scan
def lscan '
	if ($# != 4) {
		eprint "Usage:  lscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan H H K K $1 $2 $3 $4
'
# delta-temperature scan (tscan relative to current position)
def dtscan '
	if ($# != 4 && $# != 5) {
		eprint "Usage:  dtscan start finish intervals time [sleep]"
		exit
	} 
	tscan TEMP_SP+($1) TEMP_SP+($2) $3 $4 $5
'
#++++ install source file:  /home/sgm/spec/macros/scans1.mac
#
#  @(#)scans1.mac	6.17  06/27/15 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2006,2008,2010,2011,2012,2013,2014,2015
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#########################################################################
#
#                        SCAN-HELPER MACROS
#
#########################################################################
#
#  _ascan scans the number of motors given by _nm.
#  The arrays _m[], _s[], _f[] and _d[] contain the motor
#  numbers, start, finish and step sizes for each of the
#  scanned motors.  The macros ascan, a2scan, a3scan and
#  a4scan call _ascan.
#
def _ascan '
	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} ;
	{
	 local i
	 for (i=0;i<_nm;i++) {
		 _bad_lim = 0
		 _chk_lim _m[i] _s[i]
		 _chk_lim _m[i] _f[i]
		 if (_bad_lim) exit;
	 }
	}
	HEADING=_nm>1? sprintf("a%dscan ", _nm):"ascan "
	{
	 local i
	 for (i=0;i<_nm;i++) {
		HEADING=sprintf("%s%s",HEADING,sprintf(" %s %g %g ",\
			motor_mne(_m[i]),_s[i],_f[i]))
		_d[i] = (_f[i] - _s[i]) / _n1
	 }
	}
	HEADING=sprintf("%s %g %g",HEADING,_n1,_ctime)
	_n1++
	_cols=_nm+_hkl_col
	X_L = motor_name(_m[0])
	Y_L = cnt_name(DET)
	_sx = _s[0]; _fx = _f[0]
	_stype = scanType_MotorScan|(_nm<<8)
	FPRNT=VPRNT=""
	{
	 local i
	 for (i=0;i<_nm;i++) {
	     FPRNT=sprintf("%s%s  ",FPRNT,motor_name(_m[i]))
	     VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(_m[i]))
	 }
	}
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	VFMT=sprintf("%%s%%9.%df ",UP)
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i
		for (i=0;i<_nm;i++)
			A[_m[i]] = _s[i] + NPTS * _d[i]
		scan_move
		FPRNT=VPRNT=""
		for (i=0;i<_nm;i++) {
		     FPRNT=sprintf("%s%.8g ",FPRNT,A[_m[i]])
		     VPRNT=sprintf(VFMT,VPRNT,A[_m[i]])
		}
		FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
		scan_loop
		scan_data(NPTS,A[_m[0]])
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'

# Cleanup macro used by all of the scans.
def _scanabort '
	_cleanup2
	_cleanup3
	_stype &= ~scanType_ScanActive
	scan_info_update((_stype&scanType_MeshScan? _g1:NPTS) - 1, "idle")
	comment "Scan aborted after %g points" NPTS
	sync
'
# `_cleanup2' and `_cleanup3' are available for higher level scan definitions
def _cleanup2 ''
def _cleanup3 ''

# "resume" restarts aborted scans.  It relies on the user not
#  tampering with the scan loop variables.
def resume '
	if (NPTS >= (_stype&scanType_MeshScan? _n1*_n2:_n1)) {
		eprint "Last scan appears to be finished."
		exit
	}
	if (_stype&scanType_Continuous) {
		eprint "Cannot resume continous scans."
		exit
	}
	if (($1) && _stype&scanType_MeshScan)
		eprint "Can\'t change the point number of a mesh scan."
	else
		NPTS += $1
	if (NPTS < 0) NPTS  = 0
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")
	_stype |= scanType_ScanActive
	comment "Scan resumed"
	if (PLOT_MODE&1)
		plot_cntl("erase")
	_scan_on
'
# "scan_on" is the old name for "resume"
def scan_on 'resume'
#########################################################################
#
# Head macros - the heading is printed at the beginning of a scan.
#

# def Fheader '_cols++;printf("#X %gKohm (%gC)\n", TEMP_SP,DEGC_SP)'
# def Plabel  'sprintf("%7.7s %7.7s ","T-set","T-degC")'
# def Pout    'sprintf("%7.5g %7.5g ",TEMP_SP,DEGC)'
# def Flabel  '"DegC  "'
# def Fout    'sprintf("%g ",DEGC)'
# def Ftail   'fprintf(DATAFILE, "#R %d %g %g %g %g %g %g\n", \
#                 SCAN_N, pl_xMAX, pl_MAX, pl_FWHM, pl_CWHM, pl_COM, pl_SUM);'

def Fheader ''          # File header
def Plabel  '""'        # Screen (video) label
def Pout    '""'        # Screen (video) out
def Flabel  '""'        # File label
def Fout    '""'        # File out
def Ftail   ''          # File tail

cdef("user_prescan_head")
cdef("user_Fheader")
cdef("user_postscan_head")
cdef("user_scan_loop")
cdef("user_scan_plot")
cdef("user_scan_tail")

cdef("spec_scan_tail")  # Used by special scans, such as powder scans

# PRINTER has been deprecated.  Provide null definitions so old macros don't break
def Pheader ''
cdef("user_Pheader")

#########################################################################
#
# The head macro, called by all the scans.
def _head '
	user_prescan_head
	_scan_time
	waitall; get_angles; calcHKL
	NPTS = T_AV = MT_AV = 0
	DATE = date()
	TIME = TIME_END = time()
	if (_pmot < MOTORS)
		_cp = A[_pmot]
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")
	_stype |= scanType_ScanActive

	# DATA FILE HEADER
	if (DATAFILE != "") {
		local i, j, z, s

		fprintf(DATAFILE, "\n#S %d  %s\n#D %s\n",++SCAN_N,HEADING,DATE)
		if (_ctime < 0)
			fprintf(DATAFILE, "#M %g  (%s)\n", -_ctime, cnt_name(MON))
		else
			fprintf(DATAFILE, "#T %g  (%s)\n", _ctime, cnt_name(sec))

		_head_par G 0
		_head_par U 1
		_head_par UB 3
		_head_par Q 4

		fprintf(DATAFILE, "#Q %s\n", _hkl_val)

		for (i=0; i<MOTORS; i+= 8) {
			s = sprintf("#P%d ",i/8)
			for (j=i; j<i+8 && j<MOTORS;) {
				if (motor_name(mA[j]) != "unused")
					s = s sprintf("%.8g", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			fprintf(DATAFILE, "%s\n",  s)
		}

		ond; offt
		Fheader
		user_Fheader
		offd; ont

		z = _ctime < 0? sec:MON
		for (i=j=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				j++
		fprintf(DATAFILE, "#N %d\n", _cols + (MON<0? 2:3) + j)
		_cols = 0
		fprintf(DATAFILE, "#L %s%sEpoch",FPRNT,Flabel)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				fprintf(DATAFILE, "  %s",cnt_name(i))
		if (z >= 0)
			fprintf(DATAFILE, "  %s",cnt_name(z))
		fprintf(DATAFILE, "  %s\n",cnt_name(DET))
	} else
		SCAN_N++
	T_L = sprintf("Scan %d", SCAN_N)

	# TTY HEADER
	{
		local i, n, s

		if (DATAFILE == "/dev/null" || DATAFILE == "null")
			s = "**NO DATA FILE**"
		else
			s = sprintf("file = %s", DATAFILE)
		printf("\nScan %3d   %s   %s  %s  user = %s\n%s\n\n",\
			SCAN_N,DATE,s,TITLE,USER,HEADING)
		s = sprintf("  # %s%8.8s ", VPRNT,cnt_name(DET))

		tty_cntl("resized?")
		n = int((COLS - length(VPRNT) - length(Plabel) - 24) / 9)
		if (MON >= 0) {
			s = s sprintf("%8.8s ",cnt_name(MON))
			n--
		}
		s = s sprintf("%10.10s ",cnt_name(sec))

		for (i=0; i<COUNTERS && n>0; i++) {
			if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
				s = s sprintf("%8.8s ", cnt_name(i))
				n--
			}
		}
		printf("%s%s\n",s,Plabel)
	}
	user_postscan_head
'
# Used by head to print-out the total scan time
def _scan_time '{
	local t, n

	if (_stype&scanType_Continuous) {
		n = _n1
		t = _ctime
		if (_stype&scanType_MeshScan) {
			n *= _n2
			t *= _n2
		}
		printf("Estimated %d points, ", n)
	} else {
		n = _stype&scanType_MeshScan? _n1*_n2:_n1
		printf("Total %d points, ", n)
		t = n * _ctime
	}
	if (_ctime < 0) {
		printf("%g %s counts", -t,cnt_name(MON))
		if (MON_RATE) {
			t /= -MON_RATE
			printf("\nEstimated ")
		}
	}
	if (_sleep)
		t += n*_sleep
	if (t > 0) {
		local h, m, s
		h=int(t/3600); m=int(t/60)-h*60; s=int(t)-h*3600-m*60
		printf("%g seconds", t)
		if (h || m)
			printf(" (%d:%2.2d:%2.2d)",h,m,s)
	}
	printf("\n")
}'
# Used by head to save various geometry parameters to DATAFILE
# $1 is parameter name.  $2 is #G suffix
def _head_par '
	if (whatis("$1[0]")) {
		local i
		fprintf(DATAFILE, "#G$2")
		for (i=0;;i++)
			if (whatis(sprintf("$1[%d]", i)))
				fprintf(DATAFILE, " %.10g", $1[i])
			else break
		fprintf(DATAFILE, "\n")
	}
'

# The loop macro, called by all the scans at each iteration
def _loop '{
	local z, i, n, s

	if (!set_sim(-1) && _sleep) {
		do_sleep _sleep
	}
	measure0
	scan_count _ctime
	measure1
	measure2
	z = _ctime < 0? sec:MON
	T_AV += DEGC;
	if (z >= 0)
		MT_AV += S[z]
	s = sprintf("%3d %s%8s ", NPTS,VPRNT,S[DET])

	tty_cntl("resized?")
	n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
	if (MON >= 0) {
		s = s sprintf("%8s ", S[MON])
		n--
	}
	s = s sprintf("%10s ",S[sec])

	for (i=0; i<COUNTERS && n>0; i++) {
		if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
			s = s sprintf("%8.4g ", S[i])
			n--
		}
	}

	printf("%s%s\n",s,Pout)

	if (DATAFILE != "") {
		TIME_END = time()
		fprintf(DATAFILE,"%s%s%.3f",FPRNT,Fout,TIME_END - EPOCH)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				fprintf(DATAFILE," %.8g",S[i])
		if (z >= 0)
			fprintf(DATAFILE," %.8g",S[z])
		fprintf(DATAFILE," %.8g\n",S[DET]);
	}
        user_scan_loop
}'
# The tail macro, called by all the scans when they complete
def _tail '
	user_scan_tail
	spec_scan_tail
	cdef("cleanup_once", "", "scan_cleanup", "delete")
	TIME_END = time()
	ond; offt
	Ftail
	offd; ont
	_stype &= ~scanType_ScanActive
	scan_info_update((_stype&scanType_MeshScan? _g1:NPTS) - 1, "idle")
	plot
'
def setscans '
    _sleep = getval("\nSleep (settle) time before each scan point",_sleep)
    _upd_flg = yesno("Show updated moving and counting during scans",_upd_flg)
    _set_upd
    _pre_chk = yesno("Do hklscan prescan limit-check loops",_pre_chk)
    _sav_geo_mot = yesno("Save motors to data file at each point for HKL scans",\
	_sav_geo_mot)
'

def _set_upd '
	if (_upd_flg) {
		rdef _move  \'_upd_move\'
		rdef _count \'_upd_count\'
	} else {
		rdef _move  \'_ord_move\'
		rdef _count \'_ord_count\'
	}
'
# basic updated count
#       Nov 1, 1994 - removed initial "waitmove", as it interfered
#       with new count-while-moving macros.
def _upd_count '
	if ($1) for (;;) {
		count_em $1
		for (;;) {
			local   done
			get_counts
			printf("\r%3d %s%8s ", NPTS,VPRNT,S[DET])
			if (MON >= 0)
				printf("%8s ", S[MON])
			printf("%10s", S[sec])
			tty_cntl("ce")
			printf("\r")
			if (done)
				break
			sleep(UPDATE)
			done = !chk_count
		}
		chk_beam
	}
'
# ordinary move
def _ord_move 'move_em; waitmove; get_angles; calcHKL'
# ordinary count
def _ord_count 'count'

def scan_head  '_head'
def scan_loop  '_loop'
def scan_move  '_move'
def scan_count '_count'
def scan_plot  'user_scan_plot; _plot'
def scan_tail  '_tail'

# Parameterize HKL formats, to accommodate two-circle, etc. geometry

def _hkl_val 'sprintf("%g %g %g",H,K,L)'
def _hkl_val11 'sprintf("%11.5g %11.5g %11.5g",H,K,L)'
def _hkl_sym1 '"H  K  L"'
def _hkl_sym2 '"HKL"'
	       # 12345678901 12345678901 12345678901
def _hkl_sym11 '"          H           K           L"'

constant _hkl_col 3

# Some people don't use HKL
def no_hkl '
	def _hkl_val \'""\'
	def _hkl_val11 \'""\'
	def _hkl_sym1 \'""\'
	def _hkl_sym2 \'""\'
	def _hkl_sym11 \'""\'
	def calcHKL \'\'
	def savegeo \'\'
	def startgeo \'\'
	constant _hkl_col 0

	def _un \'if (whatis("\$1")&2) undef \$1\'
	_un hklscan
	_un hklmesh
	_un _hklmesh
	_un hkcircle
	_un hlcircle
	_un klcircle
	_un hkradial
	_un hlradial
	_un klradial
	_un _hklline
	_un abscan
	_un abmesh
	_un _abmesh
	_un th2th
	_un hscan
	_un kscan
	_un lscan
	_un an
	_un uan
	_un _an
	_un br
	_un ubr
	_un _br
	_un mk
	_un _mk
	_un _mk
	_un _updateHKL
	_un cal
	_un ca
	_un ci
	_un wh
	_un _var

	undef _un
'

# Usage:  _chk_lim motor position
def _chk_lim '{
	local u, t

	if ((u = dial($1, $2)) < (t = get_lim($1, -1))) {
		eprintf("%s will hit low limit at %g.\n",motor_name($1),t)
		_bad_lim++
	} else if (u > (t = get_lim($1, 1))) {
		eprintf("%s will hit high limit at %g.\n",motor_name($1),t)
		_bad_lim++
	}
}'

# _hkl_lim does _chk_lim for motors used in general HKL scan.
def _hkl_lim ''

# Scan globals
global DATE TIME TIME_END       # Start date, start and end times of scans
global HEADING TITLE SCAN_N     # Scan header, title and number
global DATAFILE                 # Data file
global FPRNT VPRNT              # File and screen (video) strings
global VFMT                     # screen (video) Format string
global X_L                      # Label for independent variable
global Y_L                      # Label for dependent variable
global T_L                      # Label for title (scan number, usually)
global NPTS                     # Counter for point number in scans
global T_AV                     # Average temperature (from DEGC)
global MT_AV                    # Average monitor counts (from S[mon])

global  _nm             # Number of motors in angle scan for _ascan
global  _m _s _f _d     # Arrays for _ascan
global _m1 _m2 _m3      # Motor numbers for 1, 2 and 3 motor scans
global _s1 _s2 _s3      # Starting positions for 1, 2 and 3 parameter scans
global _f1 _f2 _f3      # Finish positions
global _d1 _d2 _d3      # Step sizes
global _c1 _c2 _c3 _c4  # Current (or center) positions for delta scans
global _sx _fx          # Minimum and maximum x values for plotting
global _n1 _n2          # Number of points for scans
global _g1 _g2          # Point counters in grid scans
global _numgeo          # Number of motors for geometry configuration
global _cols            # Number of extra columns to add to data file
global _const           # Used with HKL radial and arc scans
global _ctime           # Count time for the scans
global _stime           # Optional sleep time for temperature scans
global _sleep           # Precounting sleep time
global _bad_lim         # Flag used in the limit-checking macros
global _pre_chk         # If set, do prescan limit checks
global _sav_geo_mot     # If set, save geo motors at each point HKL scan point
global _upd_flg         # If set, do updated counting and moving in scans
global _stype           # Scan type, where high byte holds number of motors

constant scanType_MotorScan  = 0x01     #       1  = motor scan
constant scanType_HKL_Scan   = 0x02     #       2  = hkl scan
constant scanType_TempScan   = 0x04     #       4  = temp scan
constant scanType_MeshScan   = 0x08     #       8  = mesh scan
constant scanType_TimeScan   = 0x10     #      16  = time scan
constant scanType_WithGeo    = 0x20     #      32  = motor scan includes a geo motor
constant scanType_Continuous = 0x40     #      64  = continuous scan (count while moving)
constant scanType_ScanActive = 0x80     #     128  = scanning active
constant scanType_FileScan   = 0x100    #     256  = scan from motor positions in a file
constant scanType_Parametric = 0x200    #     512  = scan with parameter such as radius or length
constant scanType_ArrayTimes = 0x400    #    1024  = take scan times from SCAN_TIMES[] for each point

global _pmot            # Motor number for powder averaging
global _pwid            # Width in degrees for powder average
global _cp              # Start position of _pmot for angle scans

if (unset("_pre_chk"))
	_pre_chk = 1

_set_upd                # Assign _move and _count definitions

#++++ install source file:  /home/sgm/spec/macros/timescan.mac
#  @(#)timescan.mac	6.3  12/13/13 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 2001,2005,2008,2009,2010,2012,2013
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#  (Based on ESRF BLISS macros.  See http://www.esrf.fr/computing/bliss.)
#
#########################################################################

def timescan '
	if ($# > 2) {
		print "Usage:  timescan [counting_time [sleep_time]]"
		exit
	}
	HEADING = "timescan"
	_timescan 0 $*
'

#  Similar to timescan but it is limited to <npoints>
#  consecutive data points.
def loopscan '
	if ($# > 3 || $1 < 1) {
		print "Usage:  loopscan npoints [counting_time [sleep_time]]"
		exit
	}

	HEADING = sprintf("loopscan %d", $1)
	_timescan $*
'

def _timescan '
	if ($# > 1) _ctime = $2; else _ctime = COUNT
	if ($# > 2) _stime = $3; else _stime = 0

	HEADING = sprintf("%s %g %g", HEADING, _ctime, _stime)
	_cols = 1
	_sx = 0; _fx= 20*((_ctime>0? _ctime:1) + _stime + _sleep)
	X_L = "Time"
	Y_L = cnt_name(DET)
	_stype = scanType_TimeScan
	FPRNT="Time  "
	VPRNT=sprintf("%9.9s ", "Time")
	_n1 = int($1)
	scan_head
	_n1 = 0
	def _scan_on \'{
		local _time maxPTS shft
		maxPTS = array_op("rows", SCAN_D)
		shft = maxPTS / 2
		for (; int($1) == 0 || NPTS < int($1); NPTS++) {
			if (NPTS - _n1 >= maxPTS) {
				SCAN_D[0:(maxPTS - shft - 1)][] = SCAN_D[shft:(maxPTS - 1)][]
				_n1 += shft
			}
			_time = time() - TIME
			FPRNT=sprintf("%g ", _time)
			VPRNT=sprintf("%9.4f ", _time)
			scan_loop
			scan_data(NPTS - _n1, _time)
			if (_time > _fx) {
				local val
				val = NPTS
				# will cause scan_plot to refresh
				NPTS = 0
				_fx += 0.1 * (_fx - _sx)
				if (_fx < _time)
					_fx = _time + 0.1 * (_time - _sx)
				_sx = SCAN_D[1][0]
				scan_plot
				NPTS = val
			}
			scan_plot
			do_sleep _stime
		}
		scan_tail
	}\'
	TIME=time()
	_scan_on
'

#++++ install source file:  /home/sgm/spec/macros/count.mac
#
#  @(#)count.mac	6.6  01/23/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2003,2007,2008,2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#
# Counting macros

# Test if a counter channel should be displayed
def is_using_counter(n) '{
	if (cnt_name(n) == "unused")
		return(0);
	if (counter_par(n, "disable"))
		return(0);
	return(1);
}'

# local hooks to hardware counting from user level
def user_precount ''
def user_postcount ''

# count_em is the lowest level counting macro.
# tcount() and mcount() are built-in functions.
def count_em '
	COUNT_TIME = $#?($1):COUNT
	user_precount
	{
	 if (COUNT_TIME)
		COUNT_TIME > 0? tcount(COUNT_TIME):mcount(-COUNT_TIME)
	}
	user_postcount
'

# local hook for all counter reads.
def user_getcounts ''

# get_counts is the lowest level counter reading macro.
def get_counts '
	getcounts
	user_getcounts
'

# a macro function wrapper for the above to shield
# local variables in the calling code from names
# used in user_getcounts
def get_counts_func() '{
	getcounts
	user_getcounts
}'


# Users can do something special before a ct command
def user_prect ''
# Users can do something special after a ct command
def user_ct ''

# A version of "ct" that shows results after a ^C
def ct '{
	cdef("cleanup_once", "show_cnts; user_ct;", "ct")
	waitmove
	user_prect
	count_em $*
	waitcount
	cdef("cleanup_once", "", "ct", "delete")
	show_cnts
	user_ct
}'

# Old version of ct ...
# A user calls "ct" to count for some interval and display results
def oct '
	waitmove
	count_em $*
	waitcount
	show_cnts
'

# Replaced uctn in release 6.00.04
def uctn 'uct'
# "count" is called by the scans to count to monitor or time.
# It runs the clock and reads the scalers.
def count '{
	waitmove
	if ($1) for (;;) {
		count_em $1
		waitcount
		get_counts
		chk_beam
	}
	if (S[sec] && MON >= 0)
		MON_RATE=S[MON]/S[sec]
}'

# The chk_beam macro is hook to allow you to put in code to see if
# you have obtained sufficient counts.

global chk_thresh

def chk_beam '
	local flag delay
	if (delay == 0)
		delay=time()
	if (set_sim(-1) || S[MON] >= chk_thresh)  {
		if (flag) {
			# You can do something here if beam had been down.
			printf("Waited %d seconds for beam.",time()-delay)
			tty_cntl("ce")
			printf("\n")
		}
		flag=delay=0
		break
	}
	if (flag == 0) {
		# You can do something here if beam is down.
		flag = 1
	}
	printf("Been waiting %d seconds for beam ...\r",time()-delay)
'
# By default, the chk_beam macro just jumps out of the count loops
def chk_beam '
	break
'

# The macro "show_cnts" reads the scalers and displays the results.
def show_cnts '{
	local   i

	get_counts
	printf("\n%s\n\n", date())
	for (i=0;i<COUNTERS;i++) {
		if (!is_using_counter(i))
			continue
		printf("%12s = %g%s\n", cnt_name(i), S[i], \
		   i != sec && S[sec]? sprintf(" (%g/s)", S[i] / S[sec]):"")
	}
}'

global COUNT            # Default count time
if (unset("COUNT"))
	COUNT = 1

# The following scaler assignments determine how scaler contents
# are used in the scans.  Use the "counters" macro to change
# these assignments.  Also, use "plotselect" for choosing which
# counters to plot.
#
# The DET counter will be the last column in the data file for a scan.
# The MON counter will be used to calculate MON_RATE.
# The MON counter will appear in the #M data file entry.
# The MON counter will be the second to last column in the scan data file.

global DET              # Scaler channel to be used as detector
global MON              # Scaler channel to be used as monitor

# Default scaler assignments.  If there are only two channels, we
# figure there is no monitor
if (unset("DET")) {
	if (COUNTERS == 2) {
		MON=-1
		DET=1
	} else {
		MON=(cnt_mne("mon") == "?")? 1:mon
		DET=(cnt_mne("det") == "?")? 2:det
	}
}

global MON_RATE		# Monitor rate (defined in count macro)
global COUNT_TIME       # Actual count time as used by count_em macro

# Don't remove this last line.
#++++ install source file:  /home/sgm/spec/macros/motor.mac
#
#  @(#)motor.mac	6.14  04/29/15 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2002,2011,2012,2013,2014,2015
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#
# Motor and motor position macros

# test if a counter channel should be displayed
def is_using_motor(n) '{
	if (motor_name(n) == "unused")
		return(0);
	if (motor_par(n, "disable"))
		return(0);
	return(1);
}'

# local hooks for all moves.
def user_premove ''
def user_postmove ''

# move_em is the lowest level motor moving macro.
# move_all is a built-in command.
def move_em '
	user_premove
	move_all
	user_postmove
'

# local hook for all motor reads.
def user_getangles ''

# get_angles is the lowest level motor reading macro.
def get_angles '
	read_motors(0)
	user_getangles
'

# a macro function wrapper for the above to shield
# local variables in the calling code from names
# used in user_getangles
def get_angles_func() '{
	read_motors(0)
	user_getangles
}'

# Define the "move_poll" macro as 'waitmove' if you don't want
# to get prompted until the motors have finished moving ...
#
# def move_poll 'waitmove'
#
# ... By default, though, the move macros return immediately
def move_poll ''

# Move a single motor
def mv    '_mmov 0x00 $*'
def umv   '_mmov 0x02 $*'

# Move a single motor to a position relative to the current
def mvr   '_mmov 0x01 $*'
def umvr  '_mmov 0x03 $*'

# Move a single motor DIAL UNITS
def mvd   '_mmov 0x04 $*'
def umvd  '_mmov 0x06 $*'

# New (June 2011) relative move uses read_motors() to get prior "commanded" position
def mvr2  '_mmov 0x09 $*'
def umvr2 '_mmov 0x0B $*'


# The ESRF macros, in particular, cause problems

def explain_1 'print "
Local motor macros used at ESRF allowed moving more than one
motor on the command line.  Standard spec macros used to only
allow one motor to be moved, but allowed the target position to
be an expression.  In spec release 6.00.06, new standard spec
macros implement both features.  The old ESRF macros are now
obsolete and conflict with the new macros.  Please use an
updated pseudo.mac source file from ESRF and type \"newmac\" in
spec.\n"
		print "
If you need to update a local copy of pseudo.mac, simply
delete everything between the lines that begin:

# -------------------- Move multiple motors with std move commands

and

#----------------------------END CHANGES -------------------------
"'

constant  old_macros_message = "\n\
Obsolete local move macros detected.\n\
Type \"explain_1\" for details.\n\n"

def _mv   'eprint old_macros_message; _mmov 0x00 $*'
def _mvr  'eprint old_macros_message; _mmov 0x01 $*'
def _mvd  'eprint old_macros_message; _mmov 0x04 $*'
def _mvr2 'eprint old_macros_message; _mmov 0x09 $*'

# Constant associative array will not work prior to release 6.00.06.
# Uncomment local _mmov_cmd and assignment, if using older release.
constant _mmov_cmd = [ 0:"mv", 2:"umv", 1:"mvr", 3:"umvr", 4:"mvd", 6:"umvd", 9:"mvr2", 11:"umvr2" ]

# Low level move macro uses eval2() to allow expressions in position
# arguments.  Just be sure not to use spaces in the expressions.
def _mmov '{
	local _i, _j, _n, _tmp[], _mot[], _pos[], _mlist, _flags, _args, _w, _mne
	#local _mmov_cmd

	#_mmov_cmd = [ 0:"mv", 2:"umv", 1:"mvr", 3:"umvr", 4:"mvd", 6:"umvd", 9:"mvr2", 11:"umvr2" ]

	if (!((_flags = $1) in _mmov_cmd)) {
		eprint "Bad flags value for _mmov"
		exit
	}

	_args = "$*"
	_n = split(substr(_args, index(_args, " ") + 1), _tmp)

	if (_n == 0 || _n%2) {
		local pre

		if (_flags&0x01)
			pre = "relative-"
		else if (_flags&04)
			pre = "dial-"
		eprintf("Usage:  %s motor %sposition [[motor %sposition] ...]\n", _mmov_cmd[_flags], pre, pre)
		exit
	}

	for (_i = _j = 0; _i < _n; _i += 2, _j++) {
		"""
		  The whatis() bits in the test below perform the following logic:
		     (symbol && (number or string) && !immutable)
		  If the above is true, the @ operator treats the argument as a string
		  and looks at the value of the variable named by the string.  Otherwise
		  the value is used as is.  The immutable test is to catch if the argument
		  is a mnemonic, which could be for a motor or a counter.  In that case,
		  the string name is passed to motor_num() which makes sure it is a motor
		  mnemonic.
		"""
		_w = whatis(_tmp[_i])
		_mne = (_w&0x4 && _w&0x300000 && !(_w&0x20000000))? @(_tmp[_i]):_tmp[_i]
		if ((_mot[_j] = motor_num(_mne)) < 0) {
			eprintf("Invalid motor mnemonic for %s: %s\n", _mmov_cmd[_flags], _mne)
			exit
		}
		_pos[_j] = eval2(_tmp[_i+1] "+0")
	}
	waitmove
	get_angles
	for (_i = 0; _i < _j; _i++) {
		if (_flags&0x04)         # dial
			A[_mot[_i]] = user(_mot[_i], _pos[_i])
		else if (_flags&0x08)    # relative with commanded
			A[_mot[_i]] = read_motors(0x10, _mot[_i]) + _pos[_i]
		else if (_flags&0x01)    # relative
			A[_mot[_i]] += _pos[_i]
		else                    # ordinary
			A[_mot[_i]] = _pos[_i]
		if (_flags&0x02)
			_mlist = _mlist " " _mot[_i]
	}
	move_em
	if (_flags&0x02)
		_update(_mlist)
	else
		move_poll

}'
# Home a single motor
# With three arguments, chg_dial() sets the dial position to third
# argument when home is reached
def home '
	if ($# < 1 || $# > 3) {
		eprint "Usage:  home motor [+|-] [home_pos]"
		exit
	}
	_check0 "$1"
	waitmove
	if ($# == 1)
		chg_dial($1, "home")
	else if ($# == 2) {
		if ("$2" == "+")
			chg_dial($1, "home+")
		else if ("$2" == "-")
			chg_dial($1, "home-")
		else
			chg_dial($1, "home", eval2("$2+0"))
	} else if ($# == 3) {
		if ("$2" == "+")
			chg_dial($1, "home+", $3)
		else if ("$2" == "-")
			chg_dial($1, "home-", $3)
		else {
			eprint "Usage:  home motor [+|-] [home_pos]"
			exit
		}
	}
	# Do not remove this comment
	move_poll
'

# Local hook for setting motor position.  Need to use up arguments
# to avoid syntax errors.
def user_setpos '# $*'

# Define a new motor position
def set '{
	if ($# != 2) {
		eprint "Usage:  set motor new_user_value"
		exit
	}
	local i, a[]

	_check0 "$1"
	waitmove; get_angles
	a = A
	if (chg_offset($1, $2))
		exit
	user_setpos $*
	get_angles
	for (i in a) if (a[i] != A[i]) {
		comment "%s reset from %g to %g" "motor_name(i), a[i], A[i]"
	}
}'

# Local hook for setting dial position.  Need to use up arguments
# to avoid syntax errors.
def user_setdial '# $*'

# Change a motor's dial position
def set_dial '{
	if ($# != 2) {
		eprint "Usage:  set_dial motor new_dial_value"
		exit
	}
	local new, u_old, d_old

	_check0 "$1"
	waitmove; get_angles
	d_old = dial($1, u_old = A[$1])
	new = $2
	if (d_old != new) {
	  if (new > get_lim($1, 1)) {
	    eprint "Dial value above high limit.  Please set limit first."
	    exit
	  } else if (new < get_lim($1, -1)) {
	    eprint "Dial value below low limit.  Please set limit first."
	    exit
	  }
	  if (chg_dial($1, new))
	    exit
	  if (chg_offset($1, u_old))
	    exit
	  user_setdial $*
	  if (d_old != new) {
	    comment "%s dial reset from %g to %g" "motor_name($1), d_old, new"
	  }
	}
}'

# Search for the mechanical origin and reset dial settings to zero
def zero ' {
	local i, m[], n, t

	if ($# < 1) {
		eprint "Usage:  zero motor [motor...]"
		exit
	}
	n = split("$*", m)
	for (i in m)
		if ((m[i] = motor_num(t = m[i])) < 0) {
			eprintf("Invalid motor:  \"%s\".\n", t)
			exit
		}
	waitmove; getdials
	for (i = 0; i < n; i++) {
		if (get_lim(m[i], 1) < 0) {
			eprintf(\
"%s\'s zero is above soft limit.  Please check limits.\n",motor_name(m[i]))
			continue
		}
		if (get_lim(m[i], -1) > 0) {
			eprintf(\
"%s\'s zero is below soft limit.  Please check limits.\n",motor_name(m[i]))
			continue
		}
		if (chg_dial(m[i], "home") < 0)
			exit
		waitmove
		chg_dial(m[i], 0)
		comment "%s dial reset to 0" "motor_name(m[i])"
		move_poll
	}
	get_angles
}'
# Change a motor limit
def set_lm '
	if ($# != 3) {
		eprint "Usage:  set_lm motor low high"
		exit
	}
	{
	    _check0 "$1"
	    if (!set_lim($1, dial($1, $2), dial($1, $3))) {
		printf("\n%s limits set to %g %g (dial units).\n",\
			motor_name($1), get_lim($1, -1), get_lim($1, +1))
	    }
	}
'

# show current (geometry) motor positions, only user units
def _mot '{
	local s[]
	s[0] = "name"
	s[1] = "user"
	show_motor_info(s, 2, $#==1? $1:MOTORS)
}'
# Where are all the motors?  Shows name, mnemonic, user and dial.
def wa '{
	local s[]
	waitmove
	get_angles
	printf("\nCurrent Positions  (user, dial)\n")
	s[0] = "name"
	s[1] = "mne"
	s[2] = "user"
	s[3] = "dial"
	show_motor_info(s, 4, MOTORS)
}'
# Where are all the motors?  Show only mnemonic and user units.
def wu '{
	local s[]
	waitmove
	get_angles
	printf("\nCurrent Positions\n")
	s[0] = "mne"
	s[1] = "user"
	show_motor_info(s, 2, MOTORS)
}'

# List motor limits
def lm '{
	waitmove; get_angles
	if ($# > 0) {
		wm $*
	} else {
		local s[]
		printf("\nUSER Limits (high, current, low):\n")
		s[0] = "name"
		s[1] = "ulim+"
		s[2] = "user"
		s[3] = "ulim-"
		show_motor_info(s, 4, MOTORS)
		printf("\nDIAL Limits (high, current, low):\n")
		s[1] = "lim+"
		s[2] = "dial"
		s[3] = "lim-"
		show_motor_info(s, 4, MOTORS)
	}
}'

# Check for valid motor name
def _check0 '
	if ("$1" != motor_mne($1) && "$1" != $1) {
		eprint "Invalid motor name:  $1"
		exit
	}
'

# Kludge to allow users to change precision of motor position printout
if (FRESH)
	constant UP 4   # precision

# "update" versions of wm - where motor(s)
def uwm '_update("$*", 4)'

global mA

# _assign is redefined by the various geometry motors so that
# the "indirection" array mA[] contains the "interesting" motors first.
# More importantly, for geometries that use an orientation matrix,
# the first "_numgeo" motors in mA[] MUST be in the same order as assigned
# in the C code of the geo_conf.c file (geo_fourc.c, geo_sixc.c, etc.)

def _assign '_assign_mA 0'

# The _assign_mA macro is called by each geometry's _assign macro
# with the argument set to how many "special" motors there are.  The
# special motors are assigned to the first elements of the mA[] array
# in the _assign macro.  The remaining motors are assigned in order
# to the rest of mA[] here.

def _assign_mA '{
	local   i j k

	for (i = ($1), j = 0; i < MOTORS; j++) {
		for (k = 0; k < ($1); k++)
			if (mA[k] == j)
				break
		if (k == ($1))
			mA[i++] = j
	}

}'

_assign

global UPDATE   # Update interval for real time display of motor positions

# getangles and getdials used to be built-in commands.
def getangles 'read_motors(0)'
def getdials  'read_motors(1)'

# Don't remove this line
#++++ install source file:  /home/sgm/spec/macros/slit.mac
#
#  @(#)slit.mac	6.1  07/29/12 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988,1992,1997
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
##########################################################################

#
# Some old slit macros to keep track of unmotorized slits.
#

# List slit settings
def showslits '
	for (_i = 0; _i < SLIT_N; _i++)
	   printf("Slit %d  Height = %gmm  Width = %gmm\n",_i+1,SLIT_H[_i],SLIT_W[_i])
'

# Save slit settings on file and printer
def saveslits '
	for (_i = 0; _i < SLIT_N; _i++) {
	   comment "Slit %d  %g x %g" "_i+1,SLIT_H[_i],SLIT_W[_i]"
	}
'
# Change slit settings
def setslits '
	for (_i = 0; _i < SLIT_N; _i++) {
		printf("Slit %d height (%gmm)? ", _i + 1, SLIT_H[_i])
		_t1 = input()
		printf("Slit %d width (%gmm)? ", _i + 1, SLIT_W[_i])
		_t2 = input()
		if (_t1 != "" && _t1 != SLIT_H[_i]) {
			qcomment "Slit %d height reset from %g to %g"\
				"i+1,SLIT_H[_i], _t1"
			SLIT_H[_i] = _t1
		} ;
		if (_t2 != "" && _t2 != SLIT_W[_i]) {
			qcomment "Slit %d width reset from %g to %g"\
					"_i+1,SLIT_W[_i], _t2"
			SLIT_W[_i] = _t2
		} ;
	}
'
# Change one slit setting
def setslit '
	if ($# != 3 || $1 <= 0 || $1 > SLIT_N) {
		print "Usage:  slit number height width (use . for old value)"
		exit
	} ;
    {
	_a1 = $1
	if ("$2" != "." && 0$2 != SLIT_H[_a1-1]) {
		_a2 = 0$2
		comment "Slit %d height reset from %g to %g"\
				"_a1, SLIT_H[_a1-1], _a2"
		SLIT_H[_a1-1] = _a2
	} ;
	if ("$3" != "." && 0$3 != SLIT_W[_a1-1]) {
		_a3 = 0$3
		comment "Slit %d width reset from %g to %g"\
				" _a1, SLIT_W[_a1-1], _a3"
		SLIT_W[_a1-1] = _a3
	} ;
    }
'

global   SLIT_H SLIT_W;         # slit arrays
constant SLIT_N 1               # number of slits

#++++ install source file:  /home/sgm/spec/macros/hkl.mac
#
#  @(#)hkl.mac	6.2  07/31/12 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988,1989,1990,1992,1993,1997,1998,1999,2002
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

# Move 2-theta and theta
def an  '_an $*; move_poll'
def uan '_an $*; _update("tth th")'     # "update" version of above
def _an '
	if ($# != 2) {
		eprint "Usage:  an tth th"
		exit
	} ;
	waitmove; get_angles; A[tth]=$1; A[th]=$2
	move_em
'

# Go to a Bragg position, i.e., reciprocal space coordinates H, K, and L
def br  '_br $*; move_poll'
def ubr '_br $*; _updateHKL'
def _br '
	if ($# != 3) {
		eprint "Usage:  br H K L"
		exit
	} ;
	waitmove; { H=$1; K=$2; L=$3 } get_angles
	if (calcA) {
		get_angles
		calcHKL
		exit
	}
	move_em
'
# Same as br.
def mk  '_mk $*; move_poll'
def umk '_mk $*; _updateHKL'
def _mk '
	if ($# != 3) {
		eprint "Usage:  mk H K L"
		exit
	} ;
	waitmove; { H=$1; K=$2; L=$3 } get_angles
	if (calcA) {
		get_angles
		calcHKL
		exit
	}
	move_em
'

# Calculate motor positions for a given H, K, and L
def cal '
	if ($# != 3) {
		eprint "Usage:  cal H K L"
		exit
	} ;
	{H = $1; K = $2; L = $3 }
	if (calcA) {
		waitmove; get_angles; calcHKL
		exit
	}
	calcHKL
	printf("\nCalculated Positions:\n")
	_var
'
# Calculate motor positions for a given H, K, and L,
# but reset positions to diffractometer positions
def ca '
	if ($# != 3) {
		eprint "Usage:  ca H K L"
		exit
	} ;
	{H = $1; K = $2; L = $3}
	if (calcA) {
		waitmove; get_angles; calcHKL
		exit
	}
	calcHKL
	printf("\nCalculated Positions:\n")
	_var
	waitmove; get_angles; calcHKL
'
# Where - reciprocal and real space
def wh '
	waitmove; get_angles; calcHKL
	_var
'
# Print out position variables - defined by geometry macros
def _var ''

# inverse of `ca' - calculate HKL from angles
def ci '
	if ($# != _numgeo) {
		local i, s
		s = "Usage:  ci "
		for (i=0;i<_numgeo;i++)
			s = s sprintf("%s ",motor_mne(mA[i]))
		eprintf("%s\n", s)
		exit
	} else {
		local i n a
		n = split("$*", a)
		for (i=0;i<_numgeo;i++)
			A[mA[i]] = a[i]
	}
	calcHKL
	printf("\nCalculated %s:\n", _hkl_sym2)
	_var
'

#++++ install source file:  /home/sgm/spec/macros/temper.mac
#
#  @(#)temper.mac	6.2  07/31/12 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988,1989,1990,1992,1997,2001
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#
# Temperature macros
#
global  TEMP_SP         # Temperature set point (Kohms, Volts, etc.)
global  T_LO_SP         # Set point low limit
global  T_HI_SP         # Set point high limit
global  DEGC_SP         # Temperature corresponding to setpoint

global  TEMP_CS         # Temperature control sensor
global  DEGC            # Measured temperature

## Get temperature parameters
#def starttemp '
#       T_LO = getval("Lower temperature control limit", T_LO)
#       T_HI = getval("Upper temperature control limit", T_HI)
#'
if (!(whatis("starttemp")&02))
	rdef starttemp ''

# Display temperature parameters
def showtemp '
	measuretemp
	printf("Temperature Setpoint = %g (%gC)\n",TEMP_SP,DEGC_SP)
	printf("            Measured = %g (%gC)\n",TEMP_CS,DEGC)
'
# Simple read or set temperature
def te '
	if ($# == 1) {
		settemp $1
		qcomment "Temperature Setpoint at %g" "TEMP_SP"
	}
	showtemp
'
def settemp '
	if ($# != 1) {
		print "Usage:  settemp set_point"
		exit
	} else {
		local _1
		_1 = $1
		if (_1 < T_LO_SP || _1 > T_HI_SP) {
			printf("Temp limits are %g to %g.\n",T_LO_SP,T_HI_SP)
			exit
		}
		TEMP_SP = _1
		_settemp
	}
'

# Ramp the temperature.  If temp_step_size leads to sleep times less than
# TERAMP_MIN second, a larger step size will be used to make the sleep times
# no smaller than TERAMP_MIN second.  TERAMP_MIN is initially 0.2 second.
# You can try smaller values, but you may find that the overhead
# involved adds too much to the estimated total ramp time.
# One could use time() to adjust the sleep times dynamically ...

global TERAMP_MIN
if (unset("TERAMP_MIN"))
	TERAMP_MIN=0.2

def teramp '
	if ($# != 2 && $# != 3) {
		print "Usage:  teramp set_point time [ temp_step_size ]"
		exit
	}
	{
	  local _i _rtime

	  _s1 = TEMP_SP; _f1 = $1; _rtime = $2
	  if (fabs(_f1 - _s1) > 1e-4) {
		if ($# == 3) {
		  if ((_stime = fabs($3 * _rtime / (_f1 - _s1))) < TERAMP_MIN)
			_stime = TERAMP_MIN
		} else
			_stime = _rtime < 500? 2:10
		_d1 = (_f1 - _s1) / _rtime * _stime
		comment "Ramp Temp Setpoint %g to %g in %d seconds" \
			"_s1,_f1,_rtime"
		for (_i=0; _i<=_rtime; _i+=_stime, _s1 += _d1) {
			settemp _s1
			measuretemp
			printf("Set=%7.4f  Meas=%7.4fC",TEMP_SP,DEGC)
			tty_cntl("ce")
			printf("\r")
			sleep(_stime)
		}
		settemp _f1
		printf("Set=%7.4f  Meas=%7.4fC\n\n",TEMP_SP,DEGC)
		showtemp
	  } else {
		te $1
	  }
	}
'

# Temperature to Kohms and vice-versa
#  Parameters obtained by fitting manufactures table of values.
#  No representation is made as to accuracy.

def TtoR_0 '{
	local _k        # YSI 44011 (100kohm @ 25C)  20 to 120 C
	$1 = exp(-11.2942              +5.3483e3   /(_k = ($2) + 273.15)\
		  -1.42016e5  /(_k*_k) -1.172e7    /(_k*_k*_k))
}'
def RtoT_0 '{
	local _l        # YSI 44011 (100kohm @ 25C)  20 to 120 C
	$1 = (1/(+2.2764e-3            +2.20116e-4 *(_l = log($2))\
		 +2.61027e-6 *_l*_l    +9.02451e-8 *_l*_l*_l) - 273.15)
}'

def TtoR_1 '{
	local _k        # YSI 44014 (300kohm @ 25C)  20 to 120 C
	$1 = exp(-11.1171              +5.36811e3  /(_k = ($2) + 273.15)\
		  +6.53685e3  /(_k*_k) -3.33234e7  /(_k*_k*_k))
}'
def RtoT_1 '{
	local _l        # YSI 44014 (300kohm @ 25C)  20 to 120 C
	$1 = (1/( +2.12834e-3          +2.00785e-4 *(_l = log($2))\
		  +1.73425e-6 *_l*_l   +1.29522e-7 *_l*_l*_l) - 273.15)
}'

def TtoR_2 '{
	local _k        # YSI 44032 (30kohm @ 25C)   20 to 70 C
	$1 = exp(-11.1747              +4.63571e3  /(_k = ($2) + 273.15)\
		  -1.60975e4  /(_k*_k) -2.09707e7  /(_k*_k*_k))
}'
def RtoT_2 '{
	local _l        # YSI 44032 (30kohm @ 25C)   20 to 70 C
	$1 = (1/( +2.50423e-3          +2.39428e-4 *(_l = log($2))\
		  +2.63071e-6 *_l*_l   +1.27215e-7 *_l*_l*_l) - 273.15)
}'

def TtoR_3 '{
	local _k        # YSI 44006 (10kohm @ 25C)   -10 to 120 C
	$1 = exp(-11.8427              +4.82008e3  /(_k = ($2) + 273.15)\
		  -1.70559e5  /(_k*_k) -2.72525e6  /(_k*_k*_k))
}'
def RtoT_3 '{
	local _l        # YSI 44006 (10kohm @ 25C)   -10 to 120 C
	$1 = (1/( +2.73266e-3          +2.61386e-4 *(_l = log($2))\
		  +3.38675e-6 *_l*_l   +1.31781e-7 *_l*_l*_l) - 273.15)
}'

#########################################################################
#
# Here are some sample temperature control macros for specific hardware:
#
#########################################################################
#
# Temperature macros for a Lakeshore 82C Controller    # 91C
#
#def inittemp '
#        gpib_put(12,"N3M1P50I50D50W0")
#'
#def measuretemp '{
#        local _s
#        gpib_put(12,"W0")
#        _s=gpib_get(12)
#        TEMP_SS=substr(_s,1,6)          # substr(_s,2,6)
#        TEMP_CS=substr(_s,9,6)          # substr(_s,11,6)
#        RtoT_1 DEGC TEMP_CS
#        DEGC=TEMP_CS
#        TEMP_SP=substr(_s,17,6)         # substr(_s,20,6)
#        RtoT_1 DEGC_SP TEMP_SP
#        DEGC_SP=TEMP_SP
#}'
#def _settemp '
#        gpib_put(12, sprintf("S%6.4f", _1))
#'
##########################################################################
##
## Temperature macros for home-made MIT Controller
##
#def _settemp '{
#        local _s
#        _s = int(32767*_1/10)
#        gpib_put(4, sprintf("%c%c%c%c\160\200",\
#                0x80|( _s     &0xF), 0x90|((_s>>4 )&0xF),\
#                0xA0|((_s>>8 )&0xF), 0xB0|((_s>>12)&0xF)))
#}'
#
##########################################################################
##
## Temperature macros for home-made Harvard Controller
##
#def measuretemp '
#        TEMP_CS = gpib_get(1)/1000
#        RtoT_0 DEGC    TEMP_CS
#        TEMP_SP = dcb(ca_get(0, 0))/10000
#        RtoT_0 DEGC_SP TEMP_SP
#}'
#def _settemp '
#        ca_put(bcd(10000*_1), 0, 0)
#'

if (!(whatis("measuretemp")&02))
	rdef measuretemp ''
if (!(whatis("_settemp")&02))
	rdef _settemp ''
if (!(whatis("measure0")&02))
	rdef measure0 ''
if (!(whatis("measure1")&02))
	rdef measure1 'measuretemp'
if (!(whatis("measure2")&02))
	rdef measure2 ''

if (FRESH) {
	T_LO_SP=-100
	T_HI_SP=100
}

# end
#++++ install source file:  /home/sgm/spec/macros/file.mac
#
#  @(#)file.mac	6.6  05/16/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2006,2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

global DATA_DIR

"""
spec datafile control-line conventions:

#C               comment line
#D date          current date and time in UNIX format
#E num           the UNIX epoch (seconds from 00:00 GMT 1/1/70)
#F name          name by which file was created
#G1 ...          geometry parameters from G[] array (geo mode, sector, etc)
#G2 ...          geometry parameters from U[] array (lattice constants, orientation reflections)
#G3 ...          geometry parameters from UB[] array (orientation matrix)
#G4 ...          geometry parameters from Q[] array (lambda, frozen angles, cut points, etc)
#I num           a normalizing factor to apply to the data
#j% ...          mnemonics of counter (% = 0,1,2,... with eight counters per row)
#J% ...          names of counters (each separated by two spaces)
#L s1  ...       labels for the data columns
#M num           data was counted to this many monitor counts
#N num [num2]    number of columns of data [ num2 sets per row ]
#o% ...          mnemonics of motors (% = 0,1,2,... with eight motors per row)
#O% ...          names of motors (each separated by two spaces)
#P% ...          positions of motors corresponding to above #O/#o
#Q H K L         a reciprocal space position (H K L)
#R               user-defined results from a scan
#S num           scan number
#T num           data was counted for this many seconds
#U               user defined
#X               a temperature
#@MCA fmt        this scan contains MCA data (array_dump() format, as in "%16C")
#@CALIB a b c    coefficients for x[i] = a + b * i + c * i * i for MCA data
#@CHANN n f l r  MCA channel information (number_saved, first_saved, last_saved, reduction coef)
#@CTIME p l r    MCA count times (preset_time, elapsed_live_time, elapsed_real_time)
#@ROI n f l      MCA ROI channel information (ROI_name, first_chan, last_chan)

"""

""" Write standard header info to spec data file """

def newfile_head(dfile, scan_num) '{
	local i, j, s, t

	if (scan_num == 0 || !file_info(dfile, "-s")) {
		constant EPOCH time()
		fprintf(dfile, "#F %s\n", dfile)
	}
	fprintf(dfile, "#E %d\n", EPOCH)
	fprintf(dfile, "#D %s\n", date())
	fprintf(dfile, "#C %s  User = %s\n", TITLE, USER)

	user_filehead_func()

	for (i = 0, s = "\n", t = ""; i < MOTORS; i += 8) {
		s = s sprintf("#O%d ", i/8)
		t = t sprintf("#o%d ", i/8)
		for (j = i; j < i + 8 && j < MOTORS;) {
			if (motor_name(mA[j]) != "unused") {
				s = s sprintf("%s", motor_name(mA[j]))
				t = t sprintf("%s", motor_mne(mA[j]))
			}
			if (j%8 == 7)
				break
			s = s "  "
			t = t " "
			j++
		}
		s = s "\n"
		t = t "\n"
	}
	fprintf(dfile, "%s%s\n", s, t)
	for (i = 0, s = t = ""; i < COUNTERS; i += 8) {
		s = s sprintf("#J%d ", i/8)
		t = t sprintf("#j%d ", i/8)
		for (j = i; j < i + 8 && j < COUNTERS;) {
			if (cnt_name(j) != "unused") {
				s = s sprintf("%s", cnt_name(j))
				t = t sprintf("%s", cnt_mne(j))
			}
			if (j%8 == 7)
				break
			s = s "  "
			t = t " "
			j++
		}
		s = s "\n"
		t = t "\n"
	}
	fprintf(dfile, "%s%s\n", s, t)
}'
"""
The user_filehead_func() wrapper protects local variables
from conflicts in the user-defined user_filehead macro.

It would be nice to eliminate the on/off calls and
insist user_filehead uses fprintf(dfile, ...), but
support for the bare print/printf() usage remains for
backward compatibility.

"""
def user_filehead_func() '{
	ond; offt
	user_filehead
	ont; offd
}'

""" newfile_f() """

def newfile_f(dfile, scan_num, quiet) '{
	local   prev

	if (DATAFILE == "null")
		DATAFILE = "/dev/null"

	prev = DATAFILE

	if (dfile == "")
		return("")

	if (dfile == "null")
		dfile = "/dev/null"

	if (!index(dfile, "/") && file_info(DATA_DIR, "-d"))
		dfile = sprintf("%s/%s", DATA_DIR, dfile)

	if ((dfile = user_filecheck(dfile)) == "")
		return("")

	if (dfile != "tty" && !file_info(dfile, "-r")) {
		if (dfile == DATAFILE)
			printf("\n\
Warning:  Same data filename as before,\n\
but file isn\'t in the %s directory.\n\
A new version of the \"%s\" will be created.\n\n", index(dfile, "/")? "same":"current", DATAFILE)

	} else if (dfile != "/dev/null" && file_info(dfile, "-e")) {
		local s, last_scan

		if (file_info(dfile, "-d")) {
			eprintf("Error:  \"%s\" is a directory.\n", dfile)
			return(DATAFILE = "/dev/null")
		}
		if (!file_info(dfile, "-f"))
			printf("Warning:  \"%s\" is not a regular file.\n", dfile)
		if (!quiet)
			printf("Note:  \"%s\" already exists.\n", dfile)
		if (file_info(dfile, "-s") && substr(getline(dfile, 0), 1, 2) != "#F")
			printf("Warning:  \"%s\" does not start with a #F header.\n", dfile)
		if (!unix(sprintf("grep \'^#S\' %s|sort -n -k 2|tail -1", dfile), s))
			if (sscanf(s, "#S %d", last_scan) == 1)
				if (last_scan != scan_num)
					printf("\
Warning:  Last scan in \"%s\" is %d != %d.\n", dfile, last_scan, scan_num)
		if (!unix(sprintf("grep \'^#S\' %s|awk \'{print $2}\'|sort|uniq -d|wc", dfile), s)) {
			local n

			if (sscanf(s, "%d", n) == 1 && n != 0)
				printf("\
Warning:  Data file \"%s\" contains duplicate scan numbers.\n", dfile)
		}
	}

	if (prev != dfile && prev != "" && prev != "0" && prev != "tty" && prev != "/dev/tty")
		close(prev)

	if (open(dfile))
		return(DATAFILE = "/dev/null")  # failed to open

	if (dfile == DATAFILE)
		SCAN_N = scan_num
	else
		newfile_head(DATAFILE = dfile, SCAN_N = scan_num)

	user_newfile_func()

	return(DATAFILE)
}'

""" user_newfile_func() protects local variables in newfile_f() """
def user_newfile_func() '{
	user_newfile
}'

def newfile '{
	local   s, dfile, scan_num, prev

	prev = DATAFILE
	if ($# == 0) {
		dfile = getsval("\nData file", DATAFILE)
		if (dfile == DATAFILE)
			scan_num = SCAN_N
		scan_num = getval("Last scan number", scan_num)
	} else {
		dfile = "$1"
		scan_num = $2
		if (dfile == DATAFILE && $# == 2)
			SCAN_N = scan_num
	}

	if (newfile_f(dfile, scan_num) == "")
		exit

	printf("Using \"%s\".  Next scan is number %d.\n", DATAFILE, SCAN_N + 1)
}'

"""
user_filecheck() lets users insert a macro to massage or test the
file name for newfile.

Here is an example that enforces a six-character limit on file names
(the split() returns the last component if arg is a path):

  def user_filecheck(s) '{
     local   arr

     if (length(arr[split(s, arr, "/") - 1]) > 7) {
	 eprintf("Filename length must be less then seven characters.\n")
	 return("")
     }
     return(s);
  }'

The default definition, below, does nothing.

"""

def user_filecheck(s) '{return(s)}'

# Let users add info at the top of the file
if (!is_macro("user_filehead"))
	cdef("user_filehead")

# Let users act on possibly changed DATAFILE and SCAN_N
if (!is_macro("user_newfile"))
	cdef("user_newfile")

if (unset("EPOCH"))
	constant EPOCH time()

if (unset("DATA_DIR"))
	DATA_DIR = "./data"

# Do not remove this line -- it keeps the parser from waiting for an "else".
#++++ install source file:  /home/sgm/spec/macros/energy.mac
#
#  @(#)energy.mac	6.4  12/04/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2003,2008,2012,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#########################################################################
#
# These macros support various monochromator configurations.  Note, that
# the configuration is automatically determined by the presence of a
# particular set of motor mnemonics in the "config" file, as described
# below:
#
#       monu or mono                            (type 1)
#               - selects a single-motor monochromator
#
#       mono, mon_y, mon_z                      (type 2)
#               - selects a three-motor monochromator such as from Kohzu,
#                 as used at several APS beamlines.  The g_mo_s parameter
#                 specifies the offset.  The mono_flag parameter selects
#                 between two configurations.  If mono_flag is zero, the
#                 configuration is one in which the theta rotation lies along
#                 the face of the first crystal (both mon_z and mon_y motions
#                 are on the second crystal, where the mon_z motion is
#                 parallel and the mon_y perpendicular to the first crystal).
#                 If mono_flag is nonzero, the theta rotation lies along
#                 the midpoint between the two crystals (the mon_y motion
#                 is on the first crystal and mon_z on the second).
#
#
#       monu, mond and montrav                  (type 3)
#               - selects a three-motor monochromator that uses the
#                 g_mo_s parameter to specify the offset between crystals
#
#       monu, mond, montrav and monoff          (type 4)
#               - selects a four-motor monochromator
#
#       mono, monp                              (type 5)
#               - selects a two-motor monochromator
#
# Global variables are:
#
#       mono_type
#               - Set to 0, 1, 2, 3, 4 or 5 to indicate type of
#                 monochromator.  If 0, there is no monochromator.
#       mono_flag
#               - A flag that may distinguish special features.
#       g_mo_d
#               - Monochromator d-spacing in Angstroms.  Can be
#                 calculated or set using setmono macro.
#       g_mo_s
#               - Fixed offset between crystals for three-motor monochromator.
#                 Can be set using setmono.
#       xtal_ind
#               - An array holding the miller indices of the crystal.
#                 Not necessary to use if entering d-spacing directly.
#       xtal_lat
#               - Holds the lattice spacing of the crystal.  Not necessary
#                 to use if entering d-spacing directly.  Lattices for Si
#                 and Ge are built-in.
#       xtal_type
#               - Is "G" for Ge, "S" for Si, or anything else for others.
#                 Not necessary to use if entering d-spacing directly.
#
# Macros included are:
#
#       calcM  energy_in_kev
#               - Calculates monochromator motor positions from argument.
#
#       calcM_local  energy_in_kev
#               - Called by calcM to calculate motor positions for
#                 nonstandard monochromator motors.  Local users must
#                 define this macro themselves.  Initially, it is defined
#                 as a no-op macro.
#       calcE
#               - Calculates LAMBDA from motor positions.
#       calcE_local
#               - Called by calcE to allow alternative calculation of
#                 LAMBDA.  Initially, defined as a no-op macro.
#       getE
#               - Displays current energy.
#       moveE
#               - Moves monochromator to correspond to some energy.
#       setE
#               - Set monochromator angles for current energy.
#       Escan
#               - Scans energy.
#
#       setmono [d] [s]
#               - Used to enter d-spacing and offset if three-motor mono.
#                 With no arguments, will prompt for value(s).  If 0 is
#                 entered for d-spacing, you can enter type of crystal
#                 and miller indices to have d-spacing calculated.
#
#       _chk_mlim
#               - Checks limits on monochromator motors, used by Escan.
#       pa_mono
#               - Displays monochromator parameters
#       sav_mono
#               - Saves monochromator parameters
#       miller
#               - Used by setmono to calculate d-spacing from miller indices
#       _assign_mono
#               - Figures out which kind of monochromator from config
#                 mnemonics.
#
#       mono_settings()
#               - Macro function that returns the string name of the
#                 file to be used to store monochromator parameters.

constant hc_over_e 12.39852     # old version used prior to spec 4.04.08
constant hc_over_e 12.39842     # J.Phys.Chem.Ref.Data, 1988, 17, 1795-1803

# calcM - Set motor positions from LAMBDA.
def calcM '{
	local   x
	if ($# != 1) {
		eprint "Usage:  calcM energy_in_Kev"
		exit
	}
	if (g_mo_d == 0) {
		eprint "Run \"setmono\" to set monochromator parameters, first."
		exit
	}
	if (($1) == 0 || (x = hc_over_e / (($1) * 2 * g_mo_d)) > 1) {
		eprintf("Unreachable energy (E=%g Kev).  Minimum is %g Kev.\n",\
			$1, hc_over_e/(2*g_mo_d))
		exit
	}
	x = asin(x)
	A[Mono] = deg(x)
	if (mono_type == 2) {
		A[mon_y] = g_mo_s / (2 * cos(x))
		if (mono_flag)
			A[mon_y] = -A[mon_y]
		A[mon_z] = g_mo_s / (2 * sin(x))
	}
	if (mono_type == 3 || mono_type == 4) {
		A[mond] = A[Mono]
		if (mono_type == 3)
			A[montrav] = g_mo_s / tan(2 * x)
		else
			A[montrav] = A[monoff] / tan(2 * x)
	}
	if (mono_type == 5)
		A[monp] = g_mo_s / (2 * cos(x))

	calcM_local ($1)
}'
# calcE - Get LAMBDA from motor positions.
def calcE '
	if (g_mo_d == 0) {
		eprint "Run \"setmono\" to set monochromator parameters, first."
		exit
	}
	if (mono_type == 3 || mono_type == 4) {
	    if (A[Mono] != A[mond])
		eprintf("Warning:  upstream mono at %g, downstream at %g.\n",\
		    A[Mono], A[mond])
	}
	LAMBDA = 2 * g_mo_d * sin(rad(A[Mono]))
	calcE_local
'
# getE - Print energy corresponding to current position and parameters.
def getE '
	waitmove; get_angles; calcE
	if (LAMBDA == 0) {
		eprint "LAMBDA is zero.  Please \"moveE\" or \"setE\"."
		exit
	}
	printf("E = %g keV, %g Angstroms\n",hc_over_e/LAMBDA,LAMBDA)
'
# moveE - Move monochromator to correspond to some energy.
def moveE '
	if ( $# != 1) {
		eprint "Usage:  moveE energy_in_KeV"
		exit
	} 
	if (($1) <= 0) {
		eprint "Can only deal with positive energies."
		exit
	}
	waitmove; get_angles; calcM $1
	move_em; waitmove; get_angles; calcE
	comment "Monochromator moved to E = %g KeV" hc_over_e/LAMBDA
'
# setE - Set monochromator angles for to correspond to some energy.
#         (Note:  the angles must all be saved after calcM, as the
#         "set" macro does a get_angles, which would mess up values in A[].
def setE '
	if ( $# != 1) {
		eprint "Usage:  setE energy_in_KeV"
		exit
	} else {
		local   _1 _2 _3 _4 _5 _6

		if (($1) <= 0) {
			eprint "Can only deal with positive energies."
			exit
		}
		waitmove; get_angles; calcM $1

		_1 = A[Mono]
		_2 = A[montrav]
		_3 = A[mond]
		_4 = A[mon_y]
		_5 = A[mon_z]
		_6 = A[monp]
		get_angles
		if (A[Mono] != _1) {
			if (motor_mne(Mono) == "monu") {
				set monu _1
			} else {
				set mono _1
			}
		}
		if (mono_type == 2) {
			if (A[mon_y] != _4) {
				set mon_y _4
			}
			if (A[mon_z] != _5) {
				set mon_z _5
			}
		}
		if (mono_type == 3 || mono_type == 4) {
			if (A[montrav] != _2) {
				set montrav _2
			}
			if (A[mond] != _3) {
				set mond _3
			}
		}
		if (mono_type == 5) {
			set monp _6
		}
		get_angles; calcE
		comment "Monochromator set to %g KeV" hc_over_e/LAMBDA
	}
'

# Escan - Scans energy.
def Escan '
	if ($# != 4 && $# != 5 || $# == 5 && "$5" != "fixQ") {
		eprint "\
Usage: Escan start finish intervals time [fixQ]\n\
       (Units are KeV)\n\
       (the literal \"fixQ\" means keep HKL constant)"
		exit
	} 

	{ _s1 = $1; _f1 = $2; _n1 = int($3); _ctime = $4; }

	if (_n1 <= 0) {
		eprint "Number of Intervals <= 0"
		exit
	} 
	if (_s1 <= 0 || _f1 <= 0) {
		eprint "Can only deal with positive energies."
		exit
	}

	_bad_lim = 0
	_chk_mlim _s1
	_chk_mlim _f1
	if (_bad_lim) exit

	HEADING = sprintf("Escan %g %g %g %g%s",$1,$2,$3,$4,$#>4?" $5":"")
	_d1 = (_f1 - _s1) / _n1++
	X_L = "Energy (keV)"
	Y_L = cnt_name(DET)
	_sx = _s1; _fx = _f1

	FPRNT=sprintf("Energy  %s  ",motor_name(Mono))
	VPRNT=sprintf("%9.9s %9.9s ", "Energy",motor_name(Mono))
	_stype = scanType_MotorScan|(1<<8)
	_cols=2
	if (mono_type == 2) {
		FPRNT=sprintf("%s%s  ",FPRNT,motor_name(mon_y))
		VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(mon_y))
		_stype = scanType_MotorScan|(2<<8)
		_cols=3
	}
	if (mono_type == 3 || mono_type == 4) {
		FPRNT=sprintf("%s%s  %s  ",FPRNT,motor_name(montrav),motor_name(mond))
		VPRNT=sprintf("%s%9.9s %9.9s ",VPRNT,motor_name(montrav),motor_name(mond))
		_stype = scanType_MotorScan|(3<<8)
		_cols=4
	}
	if (mono_type == 5) {
		FPRNT=sprintf("%s%s  ",FPRNT,motor_name(monp))
		VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(monp))
		_stype = scanType_MotorScan|(2<<8)
		_cols=3
	}

	scan_head
	def _scan_on \'
	 {
	   local h_ca k_ca l_ca
	   if ("$5" == "fixQ") {
		h_ca = H
		k_ca = K
		l_ca = L
	   }
	   for (; NPTS < _n1; NPTS++) {
		local   E
		get_angles
		E = _s1 + NPTS * _d1
		calcM E; calcE
		if ("$5" == "fixQ") {
			H = h_ca
			K = k_ca
			L = l_ca
			calcA
		}
		scan_move
		calcE; E = hc_over_e / LAMBDA
		FPRNT=sprintf("%g %.8g ",E,A[Mono])
		VPRNT=sprintf("%9.*f %9.*f ",UP,E,UP,A[Mono])
		if (mono_type == 2) {
		    FPRNT=sprintf("%s%.8g ",FPRNT,A[mon_y])
		    VPRNT=sprintf("%s%9.*f ",VPRNT,UP,A[mon_y])
		}
		if (mono_type == 3 || mono_type == 4) {
		    FPRNT=sprintf("%s%.8g %.8g ",FPRNT,A[montrav],A[mond])
		    VPRNT=sprintf("%s%9.*f %9.*f ",VPRNT,UP,A[montrav],UP,A[mond])
		}
		if (mono_type == 5) {
		    FPRNT=sprintf("%s%.8g ",FPRNT,A[monp])
		    VPRNT=sprintf("%s%9.*f ",VPRNT,UP,A[monp])
		}
		scan_loop
		scan_data(NPTS, E)
		scan_plot
	   }
	 }
	 scan_tail
	\'
	_scan_on
'
# _chk_mlim - Used by Escan in prescan motor limit checks.
def _chk_mlim '
	calcM $1
	_chk_lim Mono A[Mono]
	if (mono_type == 2) {
		_chk_lim mon_y A[mon_y]
		_chk_lim mon_z A[mon_z]
	}
	if (mono_type == 3 || mono_type == 4) {
		_chk_lim mond A[mond]
		_chk_lim montrav A[montrav]
	}
	if (mono_type == 5) {
		_chk_lim monp A[monp]
	}
'
# pa_mono - Used by "pa" to display parameters.
def pa_mono '
	printf("  Monochromator:\n")
	printf("               d-spacing = %g Angstroms\n", g_mo_d)
	if (mono_type == 2 || mono_type == 3 || mono_type == 5)
		printf("              Separation = %g mm\n", g_mo_s)
'
# sav_mono - Used by "save" macro to save parameters to a file.
def sav_mono '
	printf("g_mo_d=%g\n",g_mo_d)
	if (mono_type == 2 || mono_type == 3 || mono_type == 5)
		printf("g_mo_s=%g\n",g_mo_s)
'
# If the default version of mono_settings(), below, needs to be changed,
# define a version to be put in a SPECD/site.mac, SPECD/site_f.mac
# or SPECD/SPEC/conf.mac file.

# If the same platform supports different configurations with
# separate monochromators, you want to put the monochromator
# parameters in a file unique to the configuration.  The SPEC
# variable contains the name of the configuration.  This first
# instance of mono_settings() is appropriate in such a situation.
# def mono_settings() '{
#        return(sprintf("%s/%s/mono_settings", SPECD, SPEC))
# }'

# If the same platform supports multiple configurations that
# use the same monochromator, you can put the parameters in a file
# common to all configurations.
def mono_settings() '{
	return(sprintf("%s/mono_settings", SPECD))
}'

def read_mono(f) '{
	local s, n, v, c

	if (getline(f, "open") < 0)
	    return(-1)
	while ((s = getline(f)) != -1) {
	    sscanf(s, "%*[ ]print%*[ ]\"%[^\"]", c)
	    if (sscanf(s, "constant %s %f", n, v) == 2) {
		print c
		if (@n != v) {
		    qcomment "%s reset from %g to %g" "n,@n,v"
		    constant @n v
		}
	    }
	}
	getline(f, "close")
	return(0)
}'

# setmono - Sets d-spacing and offset, if applicable.
def setmono '{
	local f, has_off, use_file

	_1 = g_mo_d
	_2 = g_mo_s
	has_off = mono_type == 2 || mono_type == 3 || mono_type == 5
	f = mono_settings()
	if (!file_info(f)) {
	    # file does not exist
	    if (unix(sprintf("cp /dev/null %s 2>/dev/null", f))) {
		# file cannot be created
		eprintf("\n\
According to the mono_settings() macro, monochromator parameters\n\
are kept in \"%s\".\n\n\
That file doesn\'t exist, and you don\'t have permission to\n\
create the file.  Have the system administrator address the\n\
permission issues.  In the meantime, the parameters will be\n\
kept in your state file as with other global variables.\n", f);
		use_file = 0
	    } else
		use_file = 1
	} else {
	    # file exists
	    if (!file_info(f, "-w")) {
		# file cannot be updated
		eprintf("\n\
Monochromator parameters are kept in\n\
\"%s\".\n\n\
You don\'t have permission to change that file.\n\
Have the system administrator make the file writable\n\
by you if that is appropriate.  In the meantime,\n\
the current parameters will be read from the file.\n", f);
		if (file_info(f, "-r")) {
		    printf("\n")
		    read_mono(f)
		} else
		    eprintf("Yikes!  %s is unreadable.\n", f)
		use_file = -1
	    } else
		use_file = 1
	}
	if (use_file >= 0) {
	    if ($# == 1)
	       _1 = $1
	    else if ($# == 2 && has_off) {
		_1 = $1; _2 = $2;
	    } else if ($# == 0) {
		_1 = getval("\n\
Enter monochromator d-spacing ... \n  or type 0 to enter crystal type",_1)
		if (_1+0 == 0)
		    miller
		if (has_off)
		    _2 = getval("\
Enter monochromator separation in millimeters", _2)
	    } else {
		if (has_off)
		    eprint "Usage:  setmono  or  setmono d [s]"
		else
		    eprint "Usage:  setmono  or  setmono d"
		exit
	    }

	    if (_1 != g_mo_d || (has_off && _2 != g_mo_s)) {
		if (use_file) {
		    unix(sprintf("cp /dev/null %s", f))
		    fprintf(f,"\
# Mono parameters last changed on %s by %s\n\n\
if (g_mo_d != %g) {\n\
   print \"Monochromator d-spacing is %g Angstroms.\"
   qcomment \"g_mo_d reset from %%g to %%g\" \"g_mo_d,%g\"\n\
}\n\
constant g_mo_d %g\n\n", date(),USER,_1,_1,_1,_1)
		    if (has_off)
			fprintf(f, "\
if (g_mo_s != %g) {\n\
   print \"Monochromator offset is %g mm.\"
   qcomment \"g_mo_s reset from %%g to %%g\" \"g_mo_s,%g\"\n\
}\n\
constant g_mo_s %g\n", _2,_2,_2,_2)
		    close(f)
		    printf("\n")
		    read_mono(f)
		} else {
		    printf("\nMonochromator d-spacing is %g Angstroms.\n",_1)
		    qcomment "g_mo_d reset from %g to %g" "g_mo_d,_1"
		    constant g_mo_d _1
		    if (has_off) {
			printf("Monochromator offset is %g mm.\n",_2)
			qcomment "g_mo_s reset from %g to %g" "g_mo_s,_2"
			constant g_mo_s _2
		    }
		}
	    }
	}
}'
# miller - Used by setmono to get d-spacing from miller indices.
def miller '{
	local i la m x even s s2

	la = xtal_lat
	x = xtal_type=="S"? "Si":xtal_type=="G"? "Ge":"other"
	m[0] = xtal_ind[0]
	m[1] = xtal_ind[1]
	m[2] = xtal_ind[2]
	x = substr(getval("Is your crystal Si, Ge or other",x),1,1)
	if (x == "s") x = "S"
	if (x == "g") x = "G"
	if (x == "S" || x == "G") {
		if (x == "S")
			la = 5.4307
		else if (x == "G")
			la = 5.65685
	} else
		la=getval("Enter the crystal lattice parameter in Angstroms",la)
	printf("Enter the Miller indices ...\n")
	m[0] = getval("  h",m[0])
	m[1] = getval("  k",m[1])
	m[2] = getval("  l",m[2])

	for (i = 0; i < 3; i++) {
		m[i] = int(m[i])
		if (!(m[i]&1))
			even++
		s += m[i]
		s2 += m[i] * m[i]
	}
	if ((x == "S" || x == "G" || !s) && even \
	    && (!s || s/4 != int(s/4) || even != 3)) {
		eprintf("Sorry, that\'s a forbidden reflection.\n")
		exit
	}
	_1 = la / sqrt(s2)
	printf("That gives a d-spacing of %g Angstroms.\n", _1)
	xtal_lat = la
	xtal_type = x
	xtal_ind[0] = m[0]
	xtal_ind[1] = m[1]
	xtal_ind[2] = m[2]
}'

global  mono_type
global  mono_flag
global  g_mo_d
global  g_mo_s
global  xtal_ind
global  xtal_lat
global  xtal_type

# _assign_mono - Checks which monochromator, if any, is being used by
#                looking at motor mnemonics.  If no monochromator seems
#                to be there, mono macros are removed.
def _assign_mono '
  if (monu < MOTORS && motor_mne(monu) == "monu") {
	if (motor_mne(mond) == "mond" && motor_mne(montrav) == "montrav") {
		if (motor_mne(monoff) == "monoff")
			constant mono_type 4
		else
			constant mono_type 3
		rdef Mono \'monu\'
	} else {
		constant mono_type 1
		if (motor_mne(mono) == "mono")
			rdef Mono \'mono\'
		else
			rdef Mono \'monu\'
	}
  } else if (mono < MOTORS && motor_mne(mono) == "mono") {
	if (motor_mne(mon_y) == "mon_y" && motor_mne(mon_z) == "mon_z")
		constant mono_type 2
	else if (motor_mne(monp) == "monp")
		constant mono_type 5
	else
		constant mono_type 1
	rdef Mono \'mono\'
  } else
	constant mono_type 0

  if (mono_type == 1)
	printf("Using macros for a single-motor monochromator.\n\n")
  else if (mono_type == 2)
	printf("Using macros for a three-motor monochromator (like Kohzu).\n\n")
  else if (mono_type == 3)
	printf("Using macros for a three-motor monochromator.\n\n")
  else if (mono_type == 4)
	printf("Using macros for a four-motor monochromator.\n\n")
  else if (mono_type == 5)
	printf("Using macros for a two-motor monochromator.\n\n")
  #
  if (mono_type && !whatis("calcE"))
	eprintf("\n\
You must start fresh (%s -f) or type \"newmac\"\n\
to set up monochromator macros.\n", SPEC)
  if (!mono_type) {
	rdef setmono \'\'
	rdef pa_mono \'\'
	rdef sav_mono \'\'

	if (is_macro("calcM")) undef calcM
	if (is_macro("calcE")) undef calcE
	if (is_macro("getE")) undef getE
	if (is_macro("moveE")) undef moveE
	if (is_macro("setE")) undef setE
	if (is_macro("Escan")) undef Escan
	if (is_macro("_chk_mlim")) undef _chk_mlim
	if (is_macro("miller")) undef miller

	unglobal  mono_type g_mo_d g_mo_s xtal_ind xtal_lat xtal_type
	cdef("user_offsim", "", "getE", "delete")
  } else {
	cdef("user_offsim", "getE;", "getE")
  }
'
_assign_mono

# Support obsolete stuff for a while
def get_E  'eprint "(get_E has been renamed getE)"; getE'
def move_E 'eprint "(move_E has been renamed moveE)"; moveE'
def set_E  'eprint "(set_E has been renamed setE)"; setE'

# Set some default parameters when starting fresh.

if (mono_type && unset("xtal_lat")) {
	xtal_type = "S"
	xtal_ind[0] = 1
	xtal_ind[1] = 1
	xtal_ind[2] = 1
	xtal_lat = 3.13542

	local f
	if (file_info(f = mono_settings(), "-r"))
		qdofile(f)
}

# If no geometry module defines calcA, make sure we have one
if (!is_macro("calcA")) {
	rdef calcA ''
}
# If no geometry module defines LAMBDA, make sure we have one
if (!is_macro("LAMBDA")) {
	global  _LAMBDA
	rdef LAMBDA '_LAMBDA'
}

# Define calcM_local to something that eats up an argument.
# Users may redefine to something useful.
if (!is_macro("calcM_local")) {
	rdef calcM_local '{local _x_; _x_=$1}'
}
# Similar for calcE_local, but no argument to absorb.
if (!is_macro("calcE_local")) {
	rdef calcE_local ''
}

# Do not remove this line -- it keeps the parser from waiting for an "else".
#++++ install source file:  /home/sgm/spec/macros/powder.mac
#
#  @(#)powder.mac	6.3  03/06/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1989,1990,1991,1992,1993,1997,2005,2009,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#
# Powder-scan macros
#
# When powder mode is turned on, all the scans will sweep the powder
# motor (_pmot) the width (_pwid) about the current point in the scan.
# The scalers will be gated open during the sweep.  The motors are
# moved at the "base" rate.  The count time parameter of the scan is
# ignored.
#

def setpowder '
	if ("$1" == "off") {
		rdef scan_move \'_move\'
		rdef scan_count \'_count\'
		comment "Powder mode off"
	} else if ("$1" == "uni")
		_pmotflag |= 2
	else if ("$1" == "-uni")
		_pmotflag &= ~2
	else {
		if ($# == 2) {
			_1 = "$1"; _2 = $2; _3 = _pmotflag&2
		} else if ($# == 0) {
			print "Enter powder parameters:"
			_1 = getval(" Motor to scan", motor_mne(_pmot))
			_2 = getval(" Full width of rock in degrees", _pwid)
			_3 = yesno(" Use unidirectional rock", _pmotflag&2)
		} else {
			print "Usage:  setpowder"
			print "        setpowder off"
			print "        setpowder [-]uni"
			print "        setpowder motor fullwidth"
			exit
		}
		local i
		for (i=0; i<MOTORS; i++)
			if (_1 == motor_mne(i)) {
				_pmot = i
				break
			}
		if (i == MOTORS) {
			printf("There is no motor named \"%s\".\n", _1)
			exit
		}
		_pmotflag=0
		for (i=0; i<_numgeo; i++)
			if (mA[i]==_pmot)
				_pmotflag=1
		if (_3)
			_pmotflag |= 2
		_pwid = _2
		rdef scan_move \'_pmove\'
		rdef scan_count \'_pcount\'
		comment "Powder mode on for %s at %g degrees" \
			"motor_mne(_pmot),_pwid"
	}
'
def powder_cleanup '{
	cdef("cleanup_once", "", "powder_setup", "delete")
	cdef("spec_scan_tail", "", "powder_setup", "delete")
	printf("\n")
	waitmove
	get_angles
	printf("Returning %s to %g\n", motor_mne(_pmot), _cp0)
	A[_pmot] = _cp0
	_move
	printf("\n")
}'
def powder_setup() '{
	_cp0 = _cp
	cdef("spec_scan_tail", "powder_cleanup;", "powder_setup")
	cdef("cleanup_once", "powder_cleanup;", "powder_setup")
}'

def _pmove '
	# Position at start of scan
	if (NPTS == 0)
		powder_setup()
	# If motor is involved in scan, must start from nominal center
	if (_stype&scanType_MotorScan) {
		local i
		for (i=0; i<_nm; i++)
			if (_pmot == _m[i]) {
				_cp = A[_pmot]
				break;
			}
	} else if (_stype&scanType_HKL_Scan && _pmotflag&1)
		_cp = A[_pmot]
	if (_pmotflag&2)
		A[_pmot] = _cp - _pwid/2
	else {
		A[_pmot] = _cp + _pwid/2
		_pwid = -_pwid
	}
	move_em; waitmove; get_angles; A[_pmot] = _cp; calcHKL
'
def _pcount_em '
	user_precount
	move_cnt
	user_postcount
'
# save COUNT_TIME in case user hook macros use it
def _pcount '{
	COUNT_TIME = $#?($1):COUNT
	for (;;) {
		waitmove
		get_angles
		A[_pmot] += _pwid
		_pcount_em
		waitmove
		get_counts
		chk_beam
		# only get here if no beam
		if (!(_pmotflag&2))
			_pwid = -_pwid
	}
}'

global  _pmotflag       # if bit 1 set, powder motor is a geometry motor
			# if bit 2 set, is a unidirectional scan

global  _cp0            # center position at start of scan

#++++ install source file:  /home/sgm/spec/macros/tweak.mac
#
#  @(#)tweak.mac	6.2  07/31/12 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1998,2007
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

# New and improved tweak macro (Aug 30, 1998)
# Features:
#   will count to time or monitor at each position with optional count time
#   can show updated moving and counting
#   can beep after each move+count
#   if settle-time parameter "_sleep" is set, will sleep before counting
#   can tweak more than one motor at a time
#   each motor can have its own direction and step size
#   changing direction changes all motor directions
#   changing step size of first motor, changes others maintain original ratio


# If you want beeping, type TW_BEEP=1.  Default is no beeping
global  TW_BEEP
if (unset("TW_BEEP"))
	TW_BEEP=0

# If you don't want updated counting/moving, type TW_UPDATE=0.
global  TW_UPDATE
if (unset("TW_UPDATE"))
	TW_UPDATE=1

# Local symbols used include:
#   n   - intially number of arguments, then number of motors
#   m[] - initially arguments, then motor numbers
#   del[] - deltas for each motor
#   dir - global tweak direction
#   ctime  - optional count time
#   dir - direction flag

def tw '{
	local   i, n, m[], del[], t, ctime, dir, d0, done

	n = split("$*", m)
	if (n < 2) {
		print "Usage:  tw mot [mot2 ...] delta [delta2 ...] [count_time]"
		exit
	}
	if (n&1)
		ctime = m[n-1]
	n = int(n/2)
	for (i = 0; i < n; i++) {
		if ((m[i] = motor_num(t = m[i])) < 0) {
			printf("Bad motor for tweak:  %s.\n", t)
			exit
		}
		del[i] = m[n+i]
	}

	print "Indicate direction with + (or p) or - (or n) or enter"
	print "new step size.  Type something else (or ^C) to quit.\n\n"

	t = "+"
	dir = 1
	for (;;) {
	    waitmove; get_angles
	    if (ctime) {
		    if (!set_sim(-1) && _sleep)
			do_sleep _sleep
		    count_em ctime;
		    if (!TW_UPDATE) {
			waitcount
			done = 1
		    } else
			done = 0
		    for (;;) {
			get_counts
			for (i = 0; i < n; i++)
			    printf("%s = %.3f, ", motor_mne(m[i]), A[m[i]])
			if (ctime < 0)
			    printf("%s = %g, ", cnt_mne(sec), S[sec])
			else if (MON >= 0)
			    printf("%s = %g, ", cnt_mne(MON), S[MON])
			printf("%s = %g, ", cnt_mne(DET), S[DET])
			tty_cntl("ce")
			if (done)
			    break
			sleep(UPDATE)
			printf("\r")
			done = !chk_count
		    }
	    } else
		    for (i = 0; i < n; i++)
			printf("%s = %.3f, ", motor_mne(m[i]), A[m[i]])
	    if (TW_BEEP) beep
	    t = getval("which way", t)
	    if (t+0 != 0) {
		    d0 = fabs(t / del[0])
		    for (i = 0; i < n; i++)
			del[i] *= d0
		    t = t<0? "-":"+"
	    }
	    if (t == "+" || t == "p")
		    dir = 1
	    else if (t == "-" || t == "n")
		    dir = -1
	    else
		    break
	    for (i = 0; i < n; i++)
		    A[m[i]] += dir * del[i]
	    move_em
	    if (!TW_UPDATE) {
		    waitmove
	    } else for (done = 0;;) {
		    get_angles
		    for (i = 0; i < n; i++)
			printf("%s = %.3f, ", motor_mne(m[i]), A[m[i]])
		    tty_cntl("ce")
		    printf("\r")
		    if (done)
			break
		    sleep(UPDATE)
		    done = !chk_move
	    }
	}
	cdef("cleanup_once", "", "tweak", "delete")
}'
#++++ install source file:  /home/sgm/spec/macros/region.mac
#
#  @(#)region.mac	6.1  07/29/12 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1990,1993,1997
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

global  _reg_n          # number of regions
global  _reg_s          # starting values (array)
global  _reg_f          # finishing values (array)
global  _reg_i          # number of intervals (array)
global  _reg_t          # count times (array)
global  _reg_scan       # string name of scan (e.g., "ascan th")

def setreg '{
	local i

	_reg_scan = getval("\nWhat is the basic scan",_reg_scan)
	rdef _rscan _reg_scan

	_reg_n = getval("Scan how many regions",_reg_n)

	for (i=0;i<_reg_n;i++) {
		printf("Enter parameters for region %d:\n", i+1)
		_reg_s[i] = getval("  Start", _reg_s[i])
		_reg_f[i] = getval("  End", _reg_f[i])
		_reg_i[i] = getval("  Intervals", _reg_i[i])
		_reg_t[i] = getval("  Count time", _reg_t[i])
	}
}'

# In the loop below, we can't use _i as the loop variable name,
# since we are using the loop variable as an argument, and the
# substitution in the macro will cause a name conflict.
def doreg '{
	local r_i
	for (r_i=0;r_i<_reg_n;r_i++) {
		_rscan _reg_s[r_i] _reg_f[r_i] _reg_i[r_i] _reg_t[r_i]
	}
}'

if (unset("_reg_scan")) {
	_reg_scan="Escan"
}

# Do not remove this line
#++++ install source file:  /home/sgm/spec/macros/getscan.mac
#
#  @(#)getscan.mac	6.1  07/29/12 CSS
#
#  "spec" Release 6
#  (c) Copyright 1991,1992,1993,1997,2001,2010
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

# Here is a macro to read in a scan from a spec data file
# It uses the "scans" utility.

def getscan '
	if ($# == 1)
		_2 = $1
	else if ($# == 4) {
		_1 = "$1"; _2 = $2; _3 = $3; _4 = $4
	} else if ($# == 0) {
		_1 = getsval("\nName of scan file", GS_file)
		_2 = getval("Scan number", GS_scan)
		_3 = getval("Column for x", GS_xcol)
		_4 = getval("Column for y", GS_ycol)
	} else {
		print "Usage:  getscan file_name scan_number x_col y_col"
		print "        getscan scan_number"
		print "        getscan"
		exit
	}
	GS_file = _1; GS_scan = _2; GS_xcol = _3; GS_ycol = _4

	if (unix(sprintf("scans +q -esdn -f %s x=%d y=%d %d >gs.tmp",\
				GS_file, GS_xcol, GS_ycol, GS_scan))) {
		exit
	}
	printf("Read %d points.\n",NPTS=scan_read("gs.tmp"))
	LDT = NPTS - 1
	T_L = sprintf("Scan %d", GS_scan)
	unix("rm -f gs.tmp")
'

global  GS_file
global  GS_scan
global  GS_xcol
global  GS_ycol

if (FRESH) {
	GS_file = "data"
	GS_scan = 1
	GS_xcol = 1
	GS_ycol = -1
}

# Do not remove this line -- it keeps the parser from waiting for an "else".
#++++ install source file:  /home/sgm/spec/macros/cplot.mac
#  @(#)cplot.mac	6.2  12/14/13 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1991,1992,1993,2001,2013
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

global CP_FILTER        # The cplot filter
global CP_FILTER_CMD

if ((whatis("CP_FILTER")>>16)&0x0800)
	CP_FILTER="psfilter"            # assign a default

# Simple macro to plot the current data.  The raw data is plotted.
# A C-PLOT command file is written in a file called cplot.tmp.
# The cplot program is then run using that file as input.
# (One could use scans.4 to do normalization, etc.)
# (Two backslashes are necessary to produce one in the output file.)

# We need to be able to work with the macros both in plot.mac and
# in plotarray.mac.  If using plot.mac, we need a dummy version of
# plot_defaults().

# CP_FILTER_CMD = 'sprintf("pdf scan_%04d.pdf", SCAN_N)'

if (unset("CP_FILTER_CMD"))
	CP_FILTER_CMD = ""

if (!plot_with_arrays)
	rdef plot_defaults() \'{}\'

def cplot_plot '{
	close("cplot.tmp")
	unix("rm -f cplot.tmp")
	on("cplot.tmp"); offt
	if (CP_FILTER_CMD && CP_FILTER_CMD != "")
		CP_FILTER = eval(CP_FILTER_CMD)
	printf("zi %s\n", CP_FILTER)
	printf("re\n")
	printf("ft 2\n")
	printf("sy L\n")
	printf("tu 1\n")
	printf("wi 3 9 14 12\n")
	printf("tx\n")
	 printf("File %s, %s\n",DATAFILE,T_L)
	 printf("%s\n",X_L)
	 printf("\n")
	 printf("%s\n",Y_L)
	 printf("\n")

	printf("zeqw\n")
	printf("gd 1\n")
	pts $*
	printf("^D\n")

	printf("zapltd\n")
	printf("sy 0\n")
	printf("zp\n")

	printf("wi 9\n")
	printf("zn 2 2\n")
	printf("\\s%s\\l\n", HEADING);
	printf("^D\n")

	printf("zn 0 20\n")

	if (plot_with_arrays) {
	  plot_defaults($#,"$1","$2","$3","$4")
	  printf("\\C%s\n", sdata_res_s1(@pl_a,pl_x,pl_y,pl_n));
	  printf("\\C\\d%s\n", sdata_res_s2(@pl_a,pl_x,pl_y,pl_n));
	} else {
	  _pl_arg $*
	  printf("\\C%s\n", splot_res1);
	  printf("\\C\\d%s\n", splot_res2);
	}

	printf("^D\n")

	printf("zs\n")
	printf("ex\n")
	ont; close("cplot.tmp")
	unix("(cplot cplot.tmp; rm -f cplot.tmp) >/dev/null 2>&1 &")
}'
#++++ install source file:  /home/sgm/spec/macros/show.mac
#
#  @(#)show.mac	6.6  01/23/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################


"""

For the following macros, the number of digits to the right
of the decimal point for motor position can be fixed at 3, 4, 5
or 6 or can be set automatically based on the resolution
given by the configured motor "step_size".  If
MOTOR_FMT_DIGITS is zero, the setting will be automatic.
Otherwise, MOTOR_FMT_DIGITS can be set to one of the values
3, 4, 5 or 6.

The wa, wu and lm macros (or any macros that use
show_motor_info() can optionally have a newline inserted
between rows.  Set MOTOR_FMT_COMPACT to a nonzero value for
the most compact display (no newline).

The macros will display as many columns of information as
will fit the screen if MOTOR_FMT_COLS is zero.  Otherwise,
if MOTOR_FMT_COLS is greater than zero and contains a value
less than the number of columns that would fit on the
screen, that number of columns will be displayed.

Note, if more than one row is needed to display the requested
information, the columns for each row will be evenly distributed
among the rows, rather than having the first row(s) use the
full line width.

Default value for the formatting variables is zero.  To restore
the traditional (pre-2013) behavior (for the most part), set these
values:

  MOTOR_FMT_DIGITS = 4
  MOTOR_FMT_COMPACT = 1
  MOTOR_FMT_COLS = 8

For updated counting macros, COUNT_FMT_COLS selects the
number of columns as above for motors.  If COUNT_FMT_COLS is
zero, as many columns as fit per row will be displayed.

By default each counter column is 12 characters wide.
Override the default be assigning a value to COUNT_FMT_DIGITS.

By default all counters are displayed with the uct macro.  If
COUNT_FMT_MAXCH is set to a number smaller than COUNTERS, only
that many counters will be displayed.

"""

global MOTOR_FMT_DIGITS
global MOTOR_FMT_COMPACT
global MOTOR_FMT_COLS
global COUNT_FMT_DIGITS
global COUNT_FMT_COLS
global COUNT_FMT_MAXCH


def setshow '{
	local i, menu[], modes

	menu[++i]["title"] = "Motor/Counter Column Formatting"
	menu[++i]["desc"] = "MOTOR_FMT_DIGITS?"
	menu[  i]["@"] = "MOTOR_FMT_DIGITS"
	menu[  i]["info"] = "\
The number of digits to the right of the decimal point for motor \
positions for certain display macros can be fixed at 3, 4, 5 or 6 \
or can be set automatically based on the resolution given by the \
configured motor step size.  If MOTOR_FMT_DIGITS is zero, the \
setting will be automatic.  Otherwise, it can be set to one of \
the above values."

	menu[++i]["desc"] = "MOTOR_FMT_COLS?"
	menu[  i]["@"] = "MOTOR_FMT_COLS"
	menu[  i]["info"] = "\
The macros will display as many columns of information as will \
fit the screen if MOTOR_FMT_COLS is zero.  Otherwise, if \
MOTOR_FMT_COLS is greater than zero and contains a value less \
than the number of columns that would fit on the screen, that \
number of columns will be displayed."

	if (MOTOR_FMT_COMPACT)
		modes |= 1
	menu[++i]["desc"] = "MOTOR_FMT_COMPACT?"
	menu[  i]["@"] = "MOTOR_FMT_COMPACT"
	menu[  i]["bit"] = 1
	menu[  i]["info"] = "\
The wa, wu and lm macros (or any macros that use \
show_motor_info()) can optionally have a newline inserted \
between motor rows.  Set MOTOR_FMT_COMPACT to a nonzero value for \
the most compact and \"classic spec\" display (no newline)."

	menu[++i]["desc"] = "COUNT_FMT_DIGITS?"
	menu[  i]["@"] = "COUNT_FMT_DIGITS"
	menu[  i]["info"] = "\
By default each counter column is 12 characters wide.  If \
COUNT_FMT_DIGITS has a value of zero, the default will be used. \
Otherwise, COUNT_FMT_DIGITS can be used to assign a value of \
from 8 to 20."

	menu[++i]["desc"] = "COUNT_FMT_COLS?"
	menu[  i]["@"] = "COUNT_FMT_COLS"
	menu[  i]["info"] = "\
For updated-counting macros, COUNT_FMT_COLS selects the number \
of columns as above for motors.  If COUNT_FMT_COLS is zero, as \
many columns as fit per row will be displayed."

	menu[++i]["desc"] = "COUNT_FMT_MAXCH?"
	menu[  i]["@"] = "COUNT_FMT_MAXCH"
	menu[  i]["info"] = "\
By default the uct (updated count) macro display alls the counters. \
If COUNT_FMT_MAXCH has a value of zero, the default will be used. \
Otherwise, COUNT_FMT_MAXCH can be used to limit the number of \
counters."

	modes = spec_menu(menu, modes, $1)

	MOTOR_FMT_COMPACT = modes&1
	if (MOTOR_FMT_DIGITS && (MOTOR_FMT_DIGITS < 3 || 6 < MOTOR_FMT_DIGITS))
		MOTOR_FMT_DIGITS = 0
	if (COUNT_FMT_DIGITS && (COUNT_FMT_DIGITS < 8 || 20 < COUNT_FMT_DIGITS))
		COUNT_FMT_DIGITS = 0
	#
}'


"""
Determine how many digits to display right of the decimal
point.  Argument m[] is an array of motor numbers.
Argument n is the number of elements in the array to
consider.

"""
def _mprec(m, n) '{
    local i, x, digits

    if ((digits = MOTOR_FMT_DIGITS) == 0)
	for (i = 0; i < n; i++) {
	    if (!is_using_motor(m[i]))
		continue
	    # find max value
	    x = int(-log10(1/fabs(motor_par(m[i], "step_size")))+.99)
	    if (x > digits)
		digits = x
	}
    if (digits <= 3)
	return(3)
    if (digits >= 6)
	return(6)
    return(digits)
}'

"""
Truncate strings containing the number values to
maximum width, but only as far as the decimal point.
If field too wide, use exponential notation to fit.

"""
def _mfit(wid, prec, s) '{
    local dp
    if (length(s) > wid) {
	dp = index(s, ".")
	if (dp < wid + 2)
	    return(sprintf("%.*s", wid, s))
	return(sprintf("%*.*e", wid, prec - 2, s))
    }
    return(s)
}'

"""
"where motor" displays user and dial postions and limits
for all motors or the list of motors on the command line.

"""
def wm '{
    local i, j, k, l, m[], n, t, s[]
    local sfmt, ffmt, cols, p, w

    if ($# == 0) {
	eprint "Usage:  wm motor [motor ...]"
	exit
    }
    n = split("$*", m)
    for (i in m)
	if ((m[i] = motor_num(t = m[i])) < 0) {
	    eprintf("Invalid motor:  \"%s\".\n", t)
	    exit
	}

    p = _mprec(m, n)        # p is precision
    w = p + 5               # w is width
    tty_cntl("resized?")
    cols = int((COLS - w) / (w + 1))
    if (MOTOR_FMT_COLS > 0 && MOTOR_FMT_COLS < cols)
	cols = MOTOR_FMT_COLS
    sfmt = sprintf("%%%d.%ds", w, w)
    ffmt = sprintf("%%%d.%df", w, p)

    # distribute evenly over needed rows
    if (n > cols) {
	i = int((n - 1) / cols) + 1
	cols = int((n - 1) / i) + 1
    }

    get_angles_func()
    for (k = 0; k < n; k += cols) {
	s[0] = sprintf("\n%*s", w, "")
	s[1] = sprintf("%*s", w, "")
	s[2] = sprintf("User\n%-*s", w, " High")
	s[3] = sprintf("%-*s", w, " Current")
	s[4] = sprintf("%-*s", w, " Low")
	s[5] = sprintf("Dial\n%-*s", w, " High")
	s[6] = sprintf("%-*s", w, " Current")
	s[7] = sprintf("%-*s", w, " Low")
	for (i = 0, j = k; i < cols && j < n; j++) {
	    s[0] = s[0] sprintf(sfmt, motor_name(m[j]))
	    s[1] = s[1] sprintf(sfmt, motor_mne(m[j]))
	    s[2] = s[2] _mfit(w, p, sprintf(ffmt, user(m[j], get_lim(m[j], 1))))
	    s[3] = s[3] _mfit(w, p, sprintf(ffmt, A[m[i]]))
	    s[4] = s[4] _mfit(w, p, sprintf(ffmt, user(m[j], get_lim(m[j], -1))))
	    s[5] = s[5] _mfit(w, p, sprintf(ffmt, get_lim(m[j], 1)))
	    s[6] = s[6] _mfit(w, p, sprintf(ffmt, dial(m[j], A[m[j]])))
	    s[7] = s[7] _mfit(w, p, sprintf(ffmt, get_lim(m[j], -1)))
	    if (++i < cols)
		for (l = 0; l < 8; l++)
		    s[l] = s[l] " "
	}
	for (i = 0; i < 8; i++)
	    print s[i]
    }
}'

"""
The first argument to show_motor_info() is an array of names of the
items to be displayed.  The second arguments is the number of items
in the array.  The item names are of the sort "name", "mne", "user",
etc., as seen in the macro definition.  The third argument is
the number of motors to display and should be either _numgeo or MOTORS.
The motors will be ordered as given by the mA[] array.

"""
def show_motor_info(f, ns, n) '{
    local i, j, k, m, s[], t
    local sfmt, ffmt, cols, p, w

    p = _mprec(mA, n)   # p is precision
    w = p + 5           # w is width
    tty_cntl("resized?")
    cols = int(COLS / (w + 1))
    if (MOTOR_FMT_COLS > 0 && MOTOR_FMT_COLS < cols)
	cols = MOTOR_FMT_COLS
    sfmt = sprintf("%%%d.%ds", w, w)
    ffmt = sprintf("%%%d.%df", w, p)

    # distribute evenly over needed rows
    if (n > cols) {
	i = int((n - 1) / cols) + 1
	cols = int((n - 1) / i) + 1
    }

    for (i = 0; i < n && i < MOTORS; i++) {
	for (k = 0; k < ns; k++)
	    s[k] = ""
	for (j = 0; i < n && i < MOTORS; i++) {
	    if (!is_using_motor(mA[i]))
		continue;
	    for (k = 0; k < ns; k++) {
		m = mA[i]
		t = (whatis("f")&0x01000000)? f[k]:f
		if (t =="name")
		    s[k] = s[k] sprintf(sfmt, motor_name(m))
		else if (t == "mne")
		    s[k] = s[k] sprintf(sfmt, motor_mne(m))
		else if (t == "user")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, A[m]))
		else if (t == "dial")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, dial(m, A[m])))
		else if (t == "lim+")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, get_lim(m, +1)))
		else if (t == "ulim+")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, user(m, get_lim(m, +1))))
		else if (t == "lim-")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, get_lim(m, -1)))
		else if (t == "ulim-")
		    s[k] = s[k] _mfit(w, p, sprintf(ffmt, user(m, get_lim(m, -1))))
	    }
	    if (j%cols == (cols-1))
		break
	    for (k = 0; k < ns; k++)
		s[k] = s[k] " "
	    j++
	}
	for (k = 0; k < ns; k++)
	    print s[k]
	# newline between motor rows ...
	if (i < n && !MOTOR_FMT_COMPACT)
	    print
    }
}'

"""
The _upd_move macro is an alternative to _ord_move, both of
which are the two available standard assignments to the
scan_move macro.  The _upd_move definition is used if
the scan option to display updated motor positions during
scans is selected.

"""
def _upd_move '{
    local i, s

    move_em
    if (_stype&scanType_MotorScan) {
	for (i = 0; i < _nm; i++)
	    s = s sprintf("%s ", _m[i])
	_update(s, 1)
    } else if (_stype&scanType_HKL_Scan) {
	for (i = 0; i < _numgeo; i++)
	    s = s sprintf("%s ", mA[i])
	_update(s, 3)
    }
    calcHKL
}'
"""
In the function _update(mlist, flag)
mlist is a string containing a list of motor numbers or mnemonics
flag bits are
    0x01 - scanning (as opposed to umv, umk).
    0x02 - include HKL
    0x04 - display positions even if not busy

Some points:
  - For scanning mode, only one row is displayed and no labels.
  - For HKL mode, the HKL values are always kept on the same row,
    which means columns may not be filled to the end of the row.
  - When scanning in HKL mode, HKL are printed first.

"""
def _update(mlist, flag) '{
    if (chk_move || flag&0x04) {
	local i, j, k, r, m[], q, s[], t[], done
	local sfmt, ffmt, rows, cols, p, w, once
	local scanning, do_hkl

	scanning = flag&0x01
	do_hkl = flag&0x02

	n = split(mlist, m)
	if (n == 0) {
	    eprint "No motors specified for updated move."
	    return
	}
	for (i = 0; i < n; i++) {
	    if ((m[i] = motor_num(j = m[i])) >= 0)
		continue;
	    eprintf("Bad motor for updated move:  \"%s\".\n", j)
	    return
	}

	p = _mprec(mA, n)   # p is precision
	w = p + 5           # w is width
	tty_cntl("resized?")
	cols = int(COLS / (w + 1))
	if (MOTOR_FMT_COLS > 0 && MOTOR_FMT_COLS < cols)
	    cols = MOTOR_FMT_COLS
	if (cols < 3)
	    cols = 3
	sfmt = sprintf("%%%d.%ds", w, w)
	ffmt = sprintf("%%%d.%df", w, p)

	if (scanning) {
	     # If scanning, just display one row.  Truncate n if necessary.
	     rows = 1
	     if (do_hkl) {
		if ((n + _hkl_col) > cols)
		    n = cols - _hkl_col
	     } else if (n > cols)
		n = cols
	} else {
	    # Figure out number of rows and columns
	    if (do_hkl) {
		if (_numgeo + _hkl_col <= cols)
		    rows = 1
		else if (_numgeo <= cols)
		    rows = 2
		else {
		    rows = int((_numgeo + _hkl_col - 1) / cols) + 1
		    cols = int((_numgeo + _hkl_col - 1) / rows) + 1
		}
		n = _numgeo
	    } else if (n > cols) {
		rows = int((n - 1) / cols) + 1
		cols = int((n - 1) / rows) + 1
	    } else
		rows = 1

	    # Set column headers
	    for (k = r = 0; k < n; k += cols, r++)
		for (i = 0, j = k; i < cols && j < n; j++) {
		    s[r] = s[r] sprintf(sfmt, motor_name(m[j]))
		    if (++i < cols)
			s[r] = s[r] " "
		}
	    if (do_hkl) {
		# put all of HKL on same row
		r = rows - 1
		s[r] = s[r] sprintf(sfmt, "H") " "
		s[r] = s[r] sprintf(sfmt, "K") " "
		if (_hkl_col == 3)
		    s[r] = s[r] sprintf(sfmt, "L")
	    }
	    print
	    if (rows == 1)
		print s[0]
	}
	for (;;) {
	    get_angles_func()
	    if (do_hkl) {
		calcHKL
		# H is defined as Q[0], etc.
		for (i = 0, q = "" ; i < _hkl_col; i++)
		    q = q _mfit(w, p, sprintf(ffmt, Q[i])) " "
	    }

	    for (k = 0, t[r = 0] = ""; k < n; k += cols, t[++r] = "") {
		if (scanning) {
		    t[r] = sprintf("%3d ", NPTS)
		    if (do_hkl)
			t[r] = q
		}
		for (i = 0, j = k; i < cols && j < n; j++) {
		    t[r] = t[r] _mfit(w, p, sprintf(ffmt, A[m[j]]))
		    if (++i < cols)
			t[r] = t[r] " "
		}
	    }

	    if (do_hkl && !scanning)
		t[rows-1] = t[rows-1] q

	    if (rows == 1)
		printf("%s\r", t[0])
	    else {
		if (once)
		    for (i = 0; i < 2 * rows; i++)
			tty_cntl("up")
		for (i = 0, once = 1; i < rows; i++) {
		    tty_cntl("ce")
		    print s[i]
		    tty_cntl("ce")
		    print t[i]
		}
	    }
	    # "done > 1" to make sure final positions are printed
	    if (done > 1)
		break
	    if (chk_move == 0)
		done++
	    else
		sleep(UPDATE)
	}
	if (!scanning)
	    print
    } else
	get_angles_func()
}'

"""
The umk/ubr macros use _updateHKL

"""
def _updateHKL '{
     local i, s

     for (i = 0; i < _numgeo; i++)
	 s = s sprintf("%s ", mA[i])
     _update(s, 2)
}'

"""
The update count macro

"""
def uct '{
    cdef("cleanup_once", "user_ct;", "uct")
    waitmove
    user_prect
    count_em $*
    if (chk_count) {
	local i, j, k, n, r, s[], t[], use[], done
	local buf, cols, w, once, max

	w = 12
	if (COUNT_FMT_DIGITS) {
	    w = COUNT_FMT_DIGITS
	    if (w < 8)
		w = 8
	    if (w > 20)
		w = 20
	}

	cols = int(COLS / (w + 1))
	if (COUNT_FMT_COLS > 0 && COUNT_FMT_COLS < cols)
	    cols = COUNT_FMT_COLS
	if (cols < 3)
	    cols = 3

	max = COUNT_FMT_MAXCH > 0? COUNT_FMT_MAXCH:COUNTERS
	for (i = j = 0; i < COUNTERS && j < max; i++)
	    if (use[i] = is_using_counter(i))
		j++

	# distribute evenly over needed rows
	if (j > cols) {
	    r = int((j - 1) / cols) + 1
	    cols = int((j - 1) / r) + 1
	}

	# form string with names for each column
	for (j = k = n = r = 0; k < COUNTERS && j < COUNTERS && n < max; k += cols, r++) {
	    for (i = 0, j = k; i < cols && j < COUNTERS && n < max; j++) {
		if (!use[j])
		     continue
		s[r] = s[r] sprintf("%*.*s", w, w, cnt_name(j))
		if (++i < cols)
		    s[r] = s[r] " "
		n++
	    }
	}
	print
	if (r == 1)
	    print s[0]

	for (;;) {
	    get_counts_func()
	    for (j = k = n = r = 0; k < COUNTERS && j < COUNTERS && n < max; k += cols, r++) {
		t[r] = ""
		for (i = 0, j = k; i < cols && j < COUNTERS && n < max; j++) {
		    if (!use[j])
			 continue
		    if (int(S[j]) == S[j])
			buf = sprintf("%*.0f", w, S[j])
		    else
			buf = sprintf("%*.9g", w, S[j])
		    if (length(buf) > w)
			buf = sprintf("%*.*g", w, w - 5, S[j])

		    t[r] = t[r] buf
		    if (++i < cols)
			t[r] = t[r] " "
		    n++
		}
	    }
	    if (r == 1)
		printf("%s\r", t[0])
	    else {
		if (once)
		    for (i = 0; i < 2 * r; i++)
			tty_cntl("up")
		for (i = 0, once = 1; i < r; i++) {
		    tty_cntl("ce")
		    print s[i]
		    tty_cntl("ce")
		    print t[i]
		}
	    }
	    # "done > 1" to make sure final values are printed
	    if (done > 1)
		break
	    sleep(UPDATE)
	    if (chk_count == 0)
		done++
	}
	if (r == 1)
	    print
    }
    cdef("cleanup_once", "", "uct", "delete")
    user_ct
}'
#++++ install source file:  /home/sgm/spec/macros/cscan.mac
#
#  @(#)cscan.mac	6.5  05/10/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################


"""
``cscan``, ``c2scan``, ``c3scan`` and ``c4scan`` are on-the-fly
scans.  While the motors move from the start to end positions, the
counters and motor positions are read continously.  Those on-the-fly
readings are the values displayed, plotted and saved.  Clearly, there
will be systematic errors in the values obtained this way, but one
should be able to use these scans to get a quick sense of the data
and locate the approximate positions of interesting features.

The ``cmesh`` scan does a series of single motor on-the-fly scans
while an additional motor is stepped through a specified range.
The scan direction is reversed after each on-the-fly scan to minimize
overhead time.

The scan arguments include the start and finish positions for each
motor, and the total time for the scan.  The speed of each motor
will be set to approximate that scan time.  An additional
optional argument specifies a sleep interval between each counter
reading.

While the motors are moved to the starting positions, the macros
time how long it takes to read the counters and motors.  These
readings are simply to provide an estimate for how many points will
be accumulated during the specified scan time.

At the beginning of the scan, the timer is set to count for a very
long time.  At each scan point, a new reading is taken from all the
counters and the previous reading is subtracted to get the net
counts during the scan interval.  The position associated with each
scan interval is the average of the current motor position reading
and the previous reading.

Only hardware controllers that allow reading counts or positions
while counting or moving will work with these scans.  The overhead
time associated with reading particular controllers will vary
greatly, and that will affect how many scans points are attainable.
For controllers that respond very quickly, one should use a small
``*sleeptime*`` at each point to avoid having an excessive amount
of data collected.

If the motor controllers don't have the option of programming the
step speed, the scans are still usable, but the ``*scantime*``
parameter will have no effect.

The macros will not set the motor to a speed faster than the
steady-state parameter in **spec**'s hardware *config* file.  If
the desired speed is less than the base-rate parameter, **spec**
will set the base-rate to half the steady-state rate.

If the motors are already at the starting point of the scan when
the macros are invoked, the readings done to estimate the overhead
time will likely estimate too short an overhead, as for most motor
controllers **spec** does not read the hardware if the motor is not
active.

"""

def cscan '
	if ($# != 4 && $# != 5) {
		eprint "Usage:  cscan  motor start finish scantime [sleeptime]"
		exit
	} 
	_check0 "$1"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_ctime = $4
	_stime = $5
	_nm = 1
	_cscan(0)
'
def c2scan '
	if ($# != 7 && $# != 8) {
		eprint "Usage:  c2scan  m1 s1 f1  m2 s2 f2 scantime [sleeptime]"
		exit
	} 
	_check0 "$1"; _check0 "$4"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_ctime = $7
	_stime = $8
	_nm = 2
	_cscan(0)
'
def c3scan '
	if ($# != 10 && $# != 11) {
		eprint "Usage:  c3scan  m1 s1 f1  m2 s2 f2  m3 s3 f3 scantime [sleeptime]"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_ctime = $10
	_stime = $11
	_nm = 3
	_cscan(0)
'
def c4scan '
	if ($# != 13 && $# != 14) {
		eprint "Usage:  c4scan  m1 s1 f1  m2 s2 f2  m3 s3 f3  m4 s4 f4  scantime [sleeptime]"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"; _check0 "$10"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_m[3] = $10; _s[3] = $11; _f[3] = $12
	_ctime = $14
	_stime = $15
	_nm = 4
	_cscan(0)
'
def cmesh '{
	if ($# != 8 && $# != 9) {
		eprint "Usage: cmesh  m1 s1 f1 scantime  m2 s2 f2  intervals [sleeptime]"
		exit
	}
	_check0 "$1"; _check0 "$5"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $5; _s[1] = $6; _f[1] = $7
	_ctime = $4
	_stime = $9
	_n2 = $8
	if (_n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	} ;
	_d[1] = (_f[1] - _s[1]) / _n2
	_nm = 2
	_cscan(1)
}'

"""
``_cscan``

	Internal macro used by ``cscan``, ``c2scan``, etc.
	The following global symbols have already been
	initialized by the calling macro::

	_nm
		number of motors to scan.

	``_m[]``
		contains motor numbers.

	``_s[]``
		contains starting position.

	``_f[]``
		contains final position.

	``_ctime``
		total count time for continuous scan.

	``_stime``
		optional sleep time between counter readings


"""

global _cscan_velocity_save[], _cscan_base_rate_save[]

def _cscan(is_mesh) '{
	local i, m, n, s, t, tmp, flag, first, speed, prev_S[], prev_A[], rmode[]
	local temp_v

	
	if (is_mesh)
		s = "cmesh "
	else {
		s = _nm>1? sprintf("c%dscan ", _nm):"cscan "
		_n2 = 0
	}
	if (_ctime <= 0) {
		eprintf("Need to specify a positive scan time in seconds for %s.\n", s)
		exit
	}

	for (i = 0; i < _nm; i++) {
		_bad_lim = 0
		_chk_lim _m[i] _s[i]
		_chk_lim _m[i] _f[i]
		if (_bad_lim) exit;
	}

	for (i = 0; i < _nm; i++) {
		m = m sprintf("%s ", _m[i])
		if (is_mesh)
			continue
		speed = fabs((_f[i] - _s[i]) * motor_par(_m[i], "step_size")) / _ctime
		###Going to check if the motor is the energy motor.  If so, dont worry about speed.
		if ((motor_mne(_m[i]) != "en") & (speed > (tmp = motor_par(_m[i], "config_velocity")))) {
			eprintf("Requested %s speed of %g for %s exceeds configured speed of %g.\n",\
			    s, speed, motor_mne(_m[i]), tmp)
				exit
		}
	}

	for (i = 0, HEADING = s; i < _nm; i++) {
		HEADING = HEADING sprintf("%s %g %g ", motor_mne(_m[i]),_s[i],_f[i])
		if (is_mesh && i == 0)
			HEADING = HEADING sprintf("%g ", _ctime)
		if (motor_mne(_m[i]) == "en") {
			_cscan_velocity_save[i] = epics_get("AM1611-4-I10:energy:trajectory:time:s")
		}
		else {
			printf("Saving motor velocity\n")
			_cscan_velocity_save[i] = motor_par(_m[i], "velocity")
		}
		_cscan_base_rate_save[i] = motor_par(_m[i], "base_rate")
	}
	HEADING = HEADING sprintf("%g %g", is_mesh? _n2:_ctime, _stime)

	cdef("cleanup_once", sprintf("cscan_cleanup(%d);", is_mesh), "cscan")

	# move to start
	waitmove
	get_angles
	for (i = flag = 0; i < _nm; i++) {
		if (A[_m[i]] != _s[i])
			flag++
		A[_m[i]] = _s[i]
	}
	if (flag)
		printf("Moving to start position ...\n")
	move_em
	#printf("Waiting 1 second\n")
	sleep(0.1)

	# Get an estimate of overhead time for reading hardware while moving to start
	for (i = 0, t = time(); i < 20; i++) {
		get_angles
		get_counts
		wait(0x20)
	}
	t = time() - t
	_n1 = _ctime / (t/20 + _stime)
	_update(m, 0)
	waitmove

	if (flag)
		print

	_cols = _nm + _hkl_col
	X_L = motor_name(_m[0])
	Y_L = cnt_name(DET)
	_sx = _s[0]
	_fx = _f[0]

	_stype = scanType_Continuous|scanType_MotorScan|(_nm<<8)
	if (is_mesh)
		_stype |= scanType_MeshScan

	for (i = 0; i < _nm; i++) {
		### If energy macro motor, set ctime instead of speed
		if (motor_mne(_m[i]) == "en") {
			printf("Setting sweep time to %g.\n", _ctime)
			motor_par(_m[i], "velocity", _ctime)
		}
		else{
		speed = fabs((_f[i] - _s[i]) * motor_par(_m[i], "step_size")) / _ctime
		if (speed != _cscan_velocity_save[i]) {
			printf("Setting %s velocity to %g (from %g)\n", \
				motor_mne(_m[i]), speed, motor_par(_m[i], "velocity"))
			motor_par(_m[i], "velocity", speed)
		}
		if (speed < _cscan_base_rate_save[i]) {
			printf("Setting %s base rate to %g (from %g)\n", \
				motor_mne(_m[i]), speed / 2, motor_par(_m[i], "base_rate"))
			motor_par(_m[i], "base_rate", speed / 2)
		}
		if (is_mesh)
			break
		}
	}

	FPRNT=VPRNT=""
	{
	 local i
	 for (i = 0; i < _nm; i++) {
	     FPRNT=sprintf("%s%s  ",FPRNT,motor_name(_m[i]))
	     VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(_m[i]))
	 }
	}
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	VFMT=sprintf("%%s%%9.%df ",UP)

	rdef _scan_on \'\'

	for (i = 0; i < _nm; i++)
	       A[_m[i]] = _f[i]

	for (_g1 = _g2 = 0; _g2 <= _n2; _g2++) {
		if (is_mesh) {
			if (_g2 != 0)
				print
			stop(2)
			waitcount
			get_angles
			if ((_g2%2) == 0)
				A[_m[0]] = _s[0]
			else
				A[_m[0]] = _f[0]
			A[_m[1]] = _s[1] + _g2 * _d[1]
			### Changed the way the outside loop works - move_em instead of scan_move


			### If outside loop is the hexapod then speed it up
			if (motor_mne(_m[1]) == "hex_xp" | \
				motor_mne(_m[1]) == "hex_yp" | \
				motor_mne(_m[1]) == "hex_zp") {
				
				temp_v = _cscan_velocity_save[1]
				motor_par(_m[1], "velocity", temp_v)

			}

			move_em
			sleep(0.1)
			while (chk_move) {
			#	printf("Moving outside loop.\n")
				sleep(0.1)
			}

			### Back to slew speed
			if (motor_mne(_m[1]) == "hex_xp" | \
                                motor_mne(_m[1]) == "hex_yp" | \
                                motor_mne(_m[1]) == "hex_zp") {

                                motor_par(_m[1], "velocity", speed)

                        }
	
			if ((_g2%2) == 0)
				A[_m[0]] = _f[0]
			else
				A[_m[0]] = _s[0]
			first = 0
			_g1 = 0
		}
		count_em 999
		#Added for sdds
		mca_cont
		#chk_beam

		### If we are scanning energy then we need to move the trajectory PV
		if (motor_mne(_m[0]) == "en") {
			printf("Moving energy.\n")
			epics_put("AM1611-4-I10:energy:trajectory:time:s", _ctime)
			if ((_g2%2) == 0)
				epics_put("AM1611-4-I10:energy:trajectory:target:eV", _f[0])
			else
				epics_put("AM1611-4-I10:energy:trajectory:target:eV", _s[0])
			epics_put("AM1611-4-I10:energy:trajectory:start", 1)
			while (epics_get("AM1611-4-I10:energy:status") != "MOVE ACTIVE"){
				sleep(0.1)
			}
		}
		else {
			move_em
			sleep(0.1)
		}
		while (chk_move) {
			if (_stime)
				sleep(_stime)
			get_angles
			get_counts
			# The following section was edited by T. Regier 2016-05-24
			# Does data normalization to constant frequency in S[0]
                        tmp = S[0]
                        S[0] = (tmp - prev_S[0])
                        prev_S[0] = tmp
			for (i = 1; i < COUNTERS; i++) {
				tmp = S[i]
				S[i] = (tmp - prev_S[i])/S[0]
				prev_S[i] = tmp
			}
			# End of edits
			for (i = 0; i < _nm; i++) {
				tmp = A[_m[i]]
				A[_m[i]] = (tmp + prev_A[i]) / 2
				prev_A[i] = tmp
				if (is_mesh)
					break
			}
			if (first == 0) {
				first = 1
				continue
			}
			FPRNT=VPRNT=""
			for (i = 0; i < _nm; i++) {
				FPRNT = sprintf("%s%.8g ",FPRNT,A[_m[i]])
				VPRNT = sprintf(VFMT,VPRNT,A[_m[i]])
			}
			FPRNT = sprintf("%s%s ",FPRNT,_hkl_val)

			T_AV += DEGC
			if (MON >= 0)
				MT_AV += S[MON]
			s = sprintf("%3d %s%8s ", NPTS, VPRNT, S[DET])

			tty_cntl("resized?")
			n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
			if (MON >= 0) {
				s = s sprintf("%8s ", S[MON])
				n--
			}
			s = s sprintf("%10s ", S[sec])

			for (i = 0; i < COUNTERS && n > 0; i++) {
				if (i != DET && i !=MON && i != sec && is_using_counter(i)) {
					s = s sprintf("%8.4g ", S[i])
					n--
				}
			}

			printf("%s%s\n",s,Pout)

			if (DATAFILE != "") {
				TIME_END = time()
				fprintf(DATAFILE, "%s%s%d", FPRNT, Fout, TIME_END - EPOCH)
				for (i = 0; i < COUNTERS; i++)
					if (i != MON && i != DET && is_using_counter(i))
						fprintf(DATAFILE, " %.8g", S[i])
				if (MON >= 0)
					fprintf(DATAFILE, " %.8g", S[MON])
				fprintf(DATAFILE, " %.8g\n", S[DET])
			}
			user_scan_loop

			scan_data(_g1, A[_m[0]])
			scan_plot
			NPTS++
			_g1++
		}
		####Need to stop the SDDs at the end of a line
		mca_single
		
	}
	cdef("cleanup_once", "", "cscan", "delete")
	cscan_cleanup(is_mesh)
	scan_tail
}'

def cscan_cleanup(is_mesh) '{
	local   i, m, b0, v0, b1, v1

	stop(2)
	waitcount
	get_angles
	print
	for (i = 0; i < _nm; i++) {
		m = motor_mne(_m[i])
		printf("Motor %s at %g\n", m, A[_m[i]])
		if (is_mesh && i)
			break
		b0 = _cscan_base_rate_save[i]
		v0 = _cscan_velocity_save[i]
		b1 = motor_par(_m[i], "base_rate")
		v1 = motor_par(_m[i], "velocity")
		if (v0 != v1) {
			printf("Setting %s velocity to %g (from %g)\n", m, v0, v1)
			motor_par(_m[i], "velocity", v0)
		}
		if (b0 != b1) {
			printf("Setting %s base rate to %g (from %g)\n", m, b0, b1)
			motor_par(_m[i], "base_rate", b0)
		}
	}
}'
#++++ install source file:  /home/sgm/spec/macros/plotarray.mac
#  @(#)plotarray.mac	6.19  07/07/15 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988-2003,2006,2007,2008,2012,2013,2014,2015
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#  (Original version based on ESRF BLISS macros.)
#
#########################################################################

constant plot_with_arrays 1

# Global variables used by these macros:

global  SCAN_D          # Scan data array.  Each row is a data point.
global  SCAN_B          # Background-subtracted version of SCAN_D (legacy code).

global  SCAN_COLS[]     # Labels of columns in SCAN_D.

global  PLOT_MOTS       # Number of independent variables (motors) in SCAN_D.
global  PLOT_NUM        # Number of dependent variables (scalers) in SCAN_D.
global  PLOT_SEL[]      # Holds PLOT_NUM mnemonics for columns user wants to plot.

global  LDT             # Last data point (index into SCAN_D).
global  PL_A            # String name of array, either SCAN_D or SCAN_B.
global  PL_X            # SCAN_D column number for x.  Always 0 in these macros.
global  PL_Y            # String with column number to be plotted separated by commas.
global  PL_YS           # String with names of columns to be plotted separated by spaces.
global  PL_Y1           # SCAN_D column for calculating CEN, pl_FWHM, etc.

global  pl_a            # pl_a, pl_x and pl_y default to PL_A, PL_X and PL_Y
global  pl_x            #  but can be overridden by plot_defaults, which is
global  pl_y            #  called by splot, rplot, plot, lp_plot, and pts
global  pl_n            # set by plot_defaults to end last row of plot

global  pl_is_SCAN_D    # Set when plotting SCAN_D (or SCAN_B)
global  PLOT_MODE
global  splot_col       # String list of color numbers for splot.
global  rplot_col       # String list of color numbers for rplot.
global  PL_DOTSIZE      # splot dot size
global  PL_LINEWID      # splot line width

global  PLOT_CNTRS      # Obsolete.  Now same value as COUNTERS

global  BG              # holds flag for background plotting.
global  bg_m            # slope of background.
global  bg_yI           # y-intercept of background.
global  bg_pts          # number of endpoints to average on each side.
global  BG_OXEL
global  BG_OYELS

# Bits for PLOT_MODE
constant PL_IN_SCAN     0x00001 # plots during scan
constant PL_AFTER_SCAN  0x00002 # plots after scan
constant PL_PRINT       0x00004 # printer plot (obsolete)
constant PL_XEXACT      0x00008 # use "xexact" mode (obsolete)
constant PL_YLOG        0x00020 # logarithmic y axis
constant PL_YZERO       0x00010 # force y min to zero
constant PL_BG_SUB      0x00040 # subtract background
constant PL_X11FILT     0x00080 # use "x11filt"
constant PL_NO_DOTS     0x00100 # don't plot with big dots
constant PL_NO_LINES    0x00200 # don't plot with lines
constant PL_NO_EBARS    0x00400 # don't draw error bars
				# 0x800 is obsolete "plot all counters"
constant PL_RAISE_1     0x01000 # bring plot window to top during scans
constant PL_RAISE_2     0x02000 # bring plot window to top after scan
constant PL_SPLOT       0x04000 # use splot utility
constant PL_ASCII       0x08000 # do ascii plots
constant PL_GRID        0x10000 # draw a background grid
constant PL_FULL_RANGE  0x20000 # show full range of x axis during scans

def resize_scan_data() '{
	local   rows, cols

	if ((rows = array_op("rows", SCAN_D)) <= 0)
		return(-1)
	if ((cols = array_op("cols", SCAN_D)) <= 0)
		return(-1)

	eprintf("Warning:  SCAN_D array is growing to %d rows.\n",rows+1024)

	{
		local   array old[rows][cols]
		local   info, meta

		old = SCAN_D
		info = array_op("info", SCAN_D)
		meta = array_op("meta", SCAN_D)
		shared array SCAN_D[rows+1024][cols]
		array_op("row_wise", SCAN_D, 1)
		SCAN_D = old
                array_op("info", SCAN_D, info)
                array_op("meta", SCAN_D, meta)
	}
	return(0)
}'

# Called at first point of a scan to set up SCAN_D columns.
# For motor scans, save all moving motors, and if any are
# associated with geometry calculations, save HKL.
# For HKL scans, save HKL and geometry motors.
# For all scans, first column is X_L from the scan
# macros.  For all scans, all counters are saved.
#
# _nm is number of motors in motor scan
# _m[] contains motors to be scanned

def scan_data_init() '{
	local   i, j, k, cols, rows, do_hkl

	global SCAN_COLS[]
        global SCAN_STATUS

	if (_stype&scanType_MotorScan) {
		cols = _nm
		for (k = 0; k < _nm; k++) {
			for (j = 0; j < _numgeo; j++)
				if (_m[k] == mA[j]) {
					do_hkl = 1
					break
				}
			if (do_hkl)
				break
		}
		if (do_hkl) {
			cols += _hkl_col
			_stype |= scanType_WithGeo
		}
	} else if (_stype&scanType_HKL_Scan)
		cols = 1 + _hkl_col + _numgeo
	else
		cols = 1

	cols += COUNTERS

	for (j in SCAN_COLS)
		delete SCAN_COLS[j]

	SCAN_COLS[i++] = X_L
	if (_stype&scanType_MotorScan) {
		for (i = 0; i < _nm; i++)
			SCAN_COLS[i] = motor_mne(_m[i])
		if (do_hkl)
			for (j = 1; j <= _hkl_col; j++, i++)
				SCAN_COLS[i] = substr("HKL", j, 1)
	} else if (_stype&scanType_HKL_Scan) {
		for (j = 1; j <= _hkl_col; j++, i++)
			SCAN_COLS[i] = substr("HKL", j, 1)
		for (j = 0; j < _numgeo; j++, i++)
			SCAN_COLS[i] = motor_mne(mA[j])
	}
	PL_Y1 -= PLOT_MOTS
	PLOT_MOTS = i
	PL_Y1 += PLOT_MOTS
	for (j = 0; j < COUNTERS; j++, i++)
		SCAN_COLS[i] = cnt_mne(j)

	if (!index(whatis("SCAN_D", "info"), "shared-mem") || array_op("rows", SCAN_D) == 0 || array_op("cols", SCAN_D) != cols) {
		shared array SCAN_D[4096][cols]
		array_op("row_wise", SCAN_D, 1)
	}
	scan_info_update(-1, "running")
        scan_meta_update()
}'

# This function is called from the scans to store the current data point.
# If a motor scan includes a geometry motor (_stype&scanType_WithGeo),
# also save HKL to SCAN_D.
def scan_data(pno, x, counts) '{
	global LDT
	local i, j, cols, rows

	if (NPTS == 0)
		scan_data_init()

	if (pno >= array_op("rows", SCAN_D)) {
		if (resize_scan_data())
			return
	}
	SCAN_D[LDT = pno][i++] = x

	if (_stype&scanType_MotorScan) {
		for (; i < _nm; i++)
			SCAN_D[pno][i] = A[_m[i]]
		if (_stype&scanType_WithGeo)
			for (j = 0; j < _hkl_col; j++, i++)
				SCAN_D[pno][i] = Q[j]
	} else if (_stype&scanType_HKL_Scan) {
		for (j = 0; j < _hkl_col; j++, i++)
			SCAN_D[pno][i] = Q[j]
		for (j = 0; j < _numgeo; j++, i++)
			SCAN_D[pno][i] = A[mA[j]]
	}

	for (j = 0; j < COUNTERS; j++, i++)
		SCAN_D[pno][i] = S[j]

	scan_info_update(pno, "running")
}'

global SCAN_PT
global SCAN_STATUS
global SCAN_META

# scan_info2update() is called before the first scan point
# and after each scan point.
def scan_info_update(npts, status) '{
	if (IS_SERVER && (SCAN_STATUS = status) == "running" && npts >= 0)
		SCAN_PT = encode("json", npts, SCAN_D[npts])
	array_op("info", SCAN_D, encode("json", npts, status))
}'

# scan_meta_update() is called before the first scan point
def scan_meta_update() '{
	local i sep
	local allmotors allmotorm allcounters allpositions
	local motors starts stops

	global SCAN_META[]

	if (_hkl_col == 3)
		hklvalues = sprintf("%3.5f;%3.5f;%3.5f", H, K, L)
	else if (_hkl_col == 2)
		hklvalues = sprintf("%3.5f;%3.5f", H, K)
	else
		hklvalues = ""

	for (i = 0, allmotors = allmotorm = allpositions = sep = ""; i < MOTORS; i++, sep = ";") {
		allmotors = allmotors sep motor_name(i)
		allmotorm = allmotorm sep motor_mne(i)
		allpositions = allpositions sep A[i]
	}
	for (i = 0, allcounters = sep = ""; i < COUNTERS; i++, sep = ";")
		allcounters  = allcounters sep cnt_mne(i)

	for (i = 0, motors = starts = stops = sep = ""; i < _nm; i++, sep = ";") {
		motors = _m[i] sep motors
		starts = _s[i] sep starts
		stops  = _f[i] sep stops
	}

	for (i = 0, selcounters = sep = ""; i < PLOT_NUM; i++, sep = ";")
		selcounters  = selcounters sep PLOT_SEL[i]

	for (i in SCAN_META)
		delete SCAN_META[i]

	SCAN_META["title"]           = HEADING
	SCAN_META["scanno"]          = SCAN_N
	SCAN_META["date"]            = date()
	SCAN_META["scantype"]        = _stype
	SCAN_META["hkl"]             = hklvalues
	SCAN_META["user"]            = USER
	SCAN_META["motors"]          = motors
	SCAN_META["starts"]          = starts
	SCAN_META["stops"]           = stops
	SCAN_META["npts"]            = _n1  #  this has to be adapted for mesh type scans
	SCAN_META["ctime"]           = _ctime
	SCAN_META["datafile"]        = DATAFILE
	if (DATAFILE in OUTFILES[]["path"])
		SCAN_META["datapath"]        = OUTFILES[DATAFILE]["path"]
	SCAN_META["allcounters"]     = allcounters
	SCAN_META["selectedcounters"]= selcounters
	SCAN_META["allmotors"]       = allmotors
	SCAN_META["allmotorm"]       = allmotorm
	SCAN_META["allpositions"]    = allpositions

	array_op("meta", SCAN_D, encode("json", SCAN_COLS, SCAN_META))
}'

# Display information about counter configuration
def show_counters() '{
	local   i, j, s

	printf("\nCurrent counter configuration:\n\n")
	printf("Num             Name      Mne  Plot\n")
	for (i = 0; i < COUNTERS; i++) {
		s = "NO"
		for (j = 0; j < PLOT_NUM; j++)
			if (cnt_num(PLOT_SEL[j]) == i) {
				s = "YES"
				break
			}
		printf("%3d %16s %8s  %4s", i, cnt_name(i), cnt_mne(i), s)
		if (i == MON)
		      printf("  (is MON)")
		if (i == DET)
		      printf("  (is DET)")
		if (counter_par(i, "disable"))
		      printf("  (Disabled)")
		print
	}
	if (MON < 0 || DET < 0 || DET >= COUNTERS) {
		print
		if (MON < 0)
			printf("Monitor counter is disabled.\n")
		if (DET < 0 || DET >= COUNTERS)
			printf("Bad value for DET (%d).\n", DET)
	}
}'

# Check that PLOT_SEL[] counters to plot are valid and assign:
#  PLOT_NUM - number of counters to plot
#      PL_Y - comma-separated list of counter numbers to plot
#     PL_YS - space-separated list counter mnemonics to plot
#     PL_Y1 - column in SCAN_D used in analysis info strings
#
# Argument is space-separated list of counter mnemonics or
# counter numbers to be plotted.  It can also be a single
# counter mnemonic.
#
# Return value is not used by standard macro, but is included
# for compatibility with legacy user macros.
#
def plotlist(s) '{
	local i, n, mne, tmp[]

	global PLOT_SEL[]

	for (i in PLOT_SEL)
		delete PLOT_SEL[i]

	PLOT_NUM = 0
	PL_Y = PL_Y1 = PL_YS = ""

	if (index(s, ","))
		n = split(s, tmp, ",")
	else
		n = split(s, tmp)
	for (i = 0; i < n; i++) {
		if ((mne = cnt_num(tmp[i])) < 0)
			continue
		PLOT_SEL[PLOT_NUM] = cnt_mne(mne)
		if (PLOT_NUM == 0) {
			PL_Y = mne
			PL_Y1 = PL_Y + PLOT_MOTS
			PL_YS = PLOT_SEL[PLOT_NUM]
		} else {
			PL_Y = PL_Y "," mne
			PL_YS = PL_YS " " PLOT_SEL[PLOT_NUM]
		}
		PLOT_NUM++
	}
	return(PL_Y)
}'
def plotselect '{
	local i, j, v, select[], using[], menu[], s, sep, newDET, newMON

	if ($# == 0)
		tty_cntl("resized?")
	if ($#)
		plotlist("$*")
	else {
		for (i in PLOT_SEL)
			select[cnt_num(PLOT_SEL[i])] = 1

		menu[1]["title"] = "Counter Configuration and Counters To Plot"
		"""
		  Since disabled counters are not included in the list stored
		  in s, keep the actual counters in the using[] array and match
		  DET and MON to the index of using[].  Note, for monitor,
		  an extra entry "none" is prepended to the list, thus
		  the +1 offset.
		"""
		for (i = 0, s = sep = ""; i < COUNTERS; i++, sep = " ") {
			if (counter_par(i, "disable"))
				menu[5 + i]["subhead"] = sprintf("%3d %16s %8s   (disabled)", i, cnt_name(i), cnt_mne(i))
			else {
				menu[5 + i]["desc"] = sprintf("%3d %16s %8s  ", i, cnt_name(i), cnt_mne(i))
				menu[5 + i]["toggle"] = select[i]
				menu[5 + i]["info"] = "Choose \[md]YES\[me] or \[md]NO\[me] to include counter in plots."
				s = s sep cnt_mne(i)
				using[++j] = i
				if (i == DET)
					newDET = j
				if (i == MON)
					newMON = j + 1
			}
		}
		menu[2]["desc"] = "Counter for DET?"
		menu[2]["list"] = s
		menu[2]["@"] = "newDET"
		menu[2]["info"] = "The DET counter is \
saved as the last column in the data file and is the first counter displayed on the screen during scans."

		menu[3]["desc"] = "Counter for MON?"
		menu[3]["list"] = "none " s
		if (MON < 0)
			newMON = 1
		menu[3]["@"] = "newMON"
		menu[3]["info"] = "The MON counter is used to calculate MON_RATE and is \
saved as the second to last column in the data file when counting to monitor."
		menu[4]["head"] = ""

		spec_menu(menu, 0, 0)

		DET = using[newDET]
		MON = newMON > 1? using[newMON - 1]:-1

		for (i = 0, s = sep = ""; i < COUNTERS; i++, sep = " ")
			if (menu[5 + i]["toggle"] == 1)
				s = s sep cnt_mne(i)
		plotlist(s)
	}

	scan_meta_update()

	if (MON >= 0 && counter_par(MON, "monitor?"))
		counter_par(MON, "monitor")
	#
}'
def counters '{
	if ($# == 2) {
		local   v

		v = $1
		if (v >= COUNTERS)
			printf("Channel %d out of range for monitor.\n", v)
		else {
			MON = v < 0? -1:v
			if (MON >= 0 && counter_par(MON, "monitor?"))
				counter_par(MON, "monitor")
		}
		v = $2
		if (v < 0 || v >= COUNTERS)
			printf("Channel %d out of range for detector.\n", v)
		else
			DET = v
		show_counters()
	} else
		plotselect
}'


def sdata_plot(arr, x, y, n) '{
	if (array_op("cols", arr) == 1 || array_op("rows", arr) == 1)
		array_plot(arr[n][x])
	else
		array_plot(arr[n][x],arr[n][y])
}'

def sdata_dump(arr, x, y, n) '{
	local elements; elements = sprintf("%d,%s",x,y)
	array_dump(arr[n][elements])
}'

# define analysis macros in terms of primary or background plot group

def arr__xMAX(a,x,y,n)  '{ return a[ array_op("rmax", a[n][y]) ][x] }'
def arr__xMIN(a,x,y,n)  '{ return a[ array_op("rmin", a[n][y]) ][x] }'
def arr__MAX(a,x,n)     '{ return array_op(    "max", a[n][x]) }'
def arr__MIN(a,x,n)     '{ return array_op(    "min", a[n][x]) }'
def arr__FWHM(a,x,y,n)  '{ return array_op(   "fwhm", a[n][x], a[n][y]) }'
def arr__CFWHM(a,x,y,n) '{ return array_op(  "cfwhm", a[n][x], a[n][y]) }'
def arr__COM(a,x,y,n)   '{ return array_op(    "com", a[n][x], a[n][y]) }'
def arr__SUM(a,x,n)     '{ return array_op(    "sum", a[n][x]) }'
def arr__SUMSQ(a,x,n)   '{ return array_op(  "sumsq", a[n][x]) }'
def arr__LHMX(a,x,y,n)  '{ return array_op(  "lhmx", a[n][x], a[n][y]) }'
def arr__UHMX(a,x,y,n)  '{ return array_op(  "uhmx", a[n][x], a[n][y]) }'

def pl_MIN   'arr__MIN  (@PL_A, PL_Y1, sprintf("0:%d",LDT))'
def pl_MAX   'arr__MAX  (@PL_A, PL_Y1, sprintf("0:%d",LDT))'
def pl_xMIN  'arr__xMIN (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_xMAX  'arr__xMAX (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_SUM   'arr__SUM  (@PL_A, PL_Y1, sprintf("0:%d",LDT))'
def pl_SUMSQ 'arr__SUMSQ(@PL_A, PL_Y1, sprintf("0:%d",LDT))'
def pl_FWHM  'arr__FWHM (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_CFWHM 'arr__CFWHM(@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_COM   'arr__COM  (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_MINX  'arr__MIN  (@PL_A, PL_X, sprintf("0:%d",LDT))'
def pl_MAXX  'arr__MAX  (@PL_A, PL_X, sprintf("0:%d",LDT))'
def pl_LHMX  'arr__LHMX (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'
def pl_UHMX  'arr__UHMX (@PL_A, PL_X, PL_Y1, sprintf("0:%d",LDT))'

def CEN  'pl_CFWHM'     # folks are used to this name

# these analysis macros use the local pl_g, pl_x and pl_y values
def ap__MIN    'arr__MIN(  arr, pl_y1, pl_n1)'          # min y
def ap__MAX    'arr__MAX(  arr, pl_y1, pl_n1)'          # max y
def ap__xMIN   'arr__xMIN( arr, pl_x1, pl_y1, pl_n1)'   # x at min y
def ap__xMAX   'arr__xMAX( arr, pl_x1, pl_y1, pl_n1)'   # x at max y
def ap__SUM    'arr__SUM(  arr, pl_y1, pl_n1)'          # sum of y values.
def ap__SUMSQ  'arr__SUMSQ(arr, pl_y1, pl_n1)'          # sum of y * y
def ap__FWHM   'arr__FWHM( arr, pl_x1, pl_y1, pl_n1)'   # full wid half max
def ap__CFWHM  'arr__CFWHM(arr, pl_x1, pl_y1, pl_n1)'   # center of FWHM
def ap__COM    'arr__COM(  arr, pl_x1, pl_y1, pl_n1)'   # center of mass
def ap__MINX   'arr__MIN(  arr, pl_x1, pl_n1)'          # min x
def ap__MAXX   'arr__MAX(  arr, pl_x1, pl_n1)'          # max x
def ap__LHMX   'arr__FWHM( arr, pl_y1, pl_n1)'          # lower half-max of x
def ap__UHMX   'arr__FWHM( arr, pl_y1, pl_n1)'          # upper half-max of x

def pts '{
	plot_defaults($#,"$1","$2","$3","$4")
	if (pl_is_SCAN_D && BG)
		do_bg(SCAN_D, pl_x, pl_y, NPTS)
	sdata_dump(@pl_a, pl_x, pl_y, pl_n)
}'

def ong  'plot_cntl("open")'            # Turn on high res graphics
def offg 'plot_cntl("close")'           # Turn off high res graphics
def zx   'ong;input("Hit return ... ");offg'

# Macros to print results of "analysis" of previous scan

# splot macro prints two lines at top of plot.  Each should be less
# than 50 characters in length.

def sdata_res_s1(arr, pl_x1, ycols, pl_n1) '{
	local pl_y1, idstr

	sscanf(ycols, "%d", pl_y1)
	if (pl_is_SCAN_D && SCAN_COLS[pl_y1])
		idstr = SCAN_COLS[pl_y1] ": "
	return(sprintf("%sPeak at %.5g is %.5g.  COM at %.5g.   ", idstr, ap__xMAX, ap__MAX, ap__COM))
}'

def sdata_res_s2(arr, pl_x1, ycols, pl_n1) '{
	local pl_y1

	sscanf(ycols, "%d", pl_y1)
	return(sprintf("FWHM is %.5g at %.5g.   ", ap__FWHM, ap__CFWHM))
}'

def sdata_res_r1(arr, pl_x1, ycols, pl_n1) '{
	local c, pl_y1, idstr, s

	c = PLOT_MODE&PL_X11FILT? 80:COLS
	sscanf(ycols, "%d", pl_y1)
	if (pl_is_SCAN_D)
		idstr = SCAN_COLS[pl_y1] ": "
	s = sprintf("%sPeak @ %.5g is %.5g  COM @ %.5g  FWHM is %.5g @ %.5g",\
		idstr, ap__xMAX, ap__MAX, ap__COM, ap__FWHM, ap__CFWHM)
	return(sprintf("%*.*s", c-9, c-9, s))
}'

# Simple 132-column plot for printer, includes form feeds and header
def lp_plot '{
	if (NPTS > 22)
		formfeed
	printf("\n%-8s   %s   file = %s  %s\n%s\n\n", T_L, DATE, DATAFILE, TITLE, HEADING)
	plot_range("auto","auto",YMIN,"auto")
	printf("   # %12.12s %12.12s", X_L, Y_L)
	plot_cntl("lp");
	plot_defaults($#,"$1","$2","$3","$4")
	if (pl_is_SCAN_D && BG)
		do_bg(SCAN_D, pl_x, pl_y, NPTS)
	sdata_plot(@pl_a, pl_x, pl_y, pl_n)
}'

# A little macro to print elapsed time of a scan.
def _elapsed(t) '{
	local h, m, s, r

	if (h = int(t/3600))      r = r sprintf("%d hour  ",h)
	if (m = int((t%3600)/60)) r = r sprintf("%d minute  ",m)
	if (s = t%60)             r = r sprintf("%d second",s)
	return r
}'

# splot [ array [ x-col [ y-col [ num-pts ]]]]
# splot [ y-col ] | [ x-col y-col [num-pts ]]

def plot_defaults(num_args, p1, p2, p3, p4) '{
	local i, n, tmp[]

	global PL_A pl_a pl_x pl_y pl_n pl_is_SCAN_D

	pl_x = PL_X
	pl_y = PL_Y
	pl_t = T_L
	pl_xl = X_L
	pl_yl = Y_L
	if (num_args == 0) {
		# num_args == 0 means using most recent scan
		pl_is_SCAN_D = 1
		PL_A = pl_a = BG? "SCAN_B":"SCAN_D"
		pl_n = LDT
		pl_y = cnt_num(PLOT_SEL[0]) + PLOT_MOTS
		pl_yl = PLOT_SEL[0]
		for (i = 1; i < PLOT_NUM; i++) {
			pl_y = pl_y "," cnt_num(PLOT_SEL[i]) + PLOT_MOTS
			pl_yl = pl_yl " " PLOT_SEL[i]
		}
		if (index(pl_n,":") == 0 && index(pl_n,",") == 0)
			pl_n = ":" pl_n
		return
	}
	if (num_args && whatis(p1)&0x10000) {
		# first argument is a data array
		pl_x = 0
		pl_y = -1
		pl_t = pl_a = p1
		pl_n = ":-1"
		pl_is_SCAN_D = p1 == "SCAN_D"? 1:0
		if (num_args > 1) {
			pl_x = _deref(p2)
			if (num_args > 2) {
				pl_y = _deref(p3)
				if (num_args > 3)
					pl_n = _deref(p4)
			}
		}
		pl_xl = "Col_" pl_x
		pl_yl = "Col_" pl_y
	} else {
		# num_args != 0 means columns specified
		pl_is_SCAN_D = 1
		PL_A = pl_a = BG? "SCAN_B":"SCAN_D"
		pl_n = LDT
		if (num_args == 1) {
			pl_y = _plot_replace_y(_deref(p1))
			pl_yl = p1
		} else if (num_args > 1) {
			pl_x = _plot_replace_x(_deref(p1))
			pl_y = _plot_replace_y(_deref(p2))
			pl_xl = SCAN_COLS[pl_x]
			pl_yl = p2
			if (num_args > 2)
				pl_n = _deref(p3)
		} else {
			local i
			for (i=0, pl_yl="" ; i < PLOT_NUM; i++)
				pl_yl = pl_yl " " PLOT_SEL[i]
		}
	}

	if (index(pl_n,":") == 0 && index(pl_n,",") == 0)
		pl_n = ":" pl_n
}'

def _plot_replace_x(str) '{
	"""Takes a string of space- or comma-separated numbers
	or mnemonics and returns a comma-separated string of numbers
	that index the SCAN_COLS[] array."""

	local i, w

	for (i = 0; i < PLOT_MOTS; i++)
		if (str == SCAN_COLS[i])
			return(i)

	return(str)
}'

def _plot_replace_y(str) '{
	"""Takes a string of space- or comma-separated counter numbers
	or mnemonics and returns a comma-separated string of counter numbers."""

	local i, n, m, s[], r

	if (index(str, ","))
		m = split(str, s, ",")
	else
		m = split(str, s)
	for (i = 0; i < m; i++) {
		if ((n = cnt_num(s[i])) >= 0)
			s[i] = n
		if (r)
			r = r "," s[i]+PLOT_MOTS
		else
			r = s[i]+PLOT_MOTS
	}
	return r
}'

def _deref(str) '{
	"""Allows an argument to ``splot``, ``pts``, etc. to be a string
	containing the argument.  For example, x="2,3,4"; splot x"""

	local wis; wis = whatis(str)

	 # test for symbol && (number or string) && !immutable/mnemonic
	if (wis&0x4 && wis&0x300000 && !(wis&0x20000000))
		return @str
	return str
}'
 
# The plot and splot macros draw a screen or high-res plot of
# the data points from a scan.  The screen plot should work
# even if the terminal has no cursor addressing, as the
# plot_move() functions become no-ops and the internal
# plotting code will draw a lp-type plot.  The plot macro is
# called at the end of scans.  The splot macro is generally
# called from the spec prompt.
#
# splot/rplot/plot arguments:
#  [array] [x-elem] [y-elem] [num-pts] [erase-flag]
# Uses global: X_L Y_L T_L PLOT_MODE BG YMIN splot_col

def splot '{ plot_defaults($#,"$1","$2","$3","$4"); draw_plot(0, 0, 1)  }'
def rplot '{ plot_defaults($#,"$1","$2","$3","$4"); draw_plot(1, $5, 0) }'

# plot is called by the standard scan tail macro
def plot '{
	if (PLOT_MODE&PL_AFTER_SCAN) {
		local s
		if (PLOT_MODE&PL_X11FILT) {
			s = "open"
			if (!(PLOT_MODE&PL_RAISE_2))
				s = s ",raise"
			plot_cntl(s)
		}
		if (PLOT_MODE&PL_SPLOT) {
			s = "open"
			if (!(PLOT_MODE&PL_RAISE_2))
				s = s ";raise"
			splot_cntl(s)
		}
		plot_defaults($#,"$1","$2","$3","$4")
		draw_plot(0, 0, 0)
	} else if (BG) {
		# make sure background calculated even if no plot
		plot_defaults($#,"$1","$2","$3","$4")
		do_bg(SCAN_D, pl_x, pl_y, NPTS)
	}
}'
#
# updating is set when called during scans
# erase_flag is probably never used
# commanded_plot is set when called from command line
#
def draw_plot(updating, erase_flag, commanded_plot) '{
	local s

	if (updating) {
		if (pl_a == "SCAN_B")
			pl_a = "SCAN_D"
	} else if (pl_is_SCAN_D && BG)
		do_bg(SCAN_D, pl_x, pl_y, NPTS)

	if (PLOT_MODE&PL_SPLOT) {
		s = "open"
		if (commanded_plot || (updating && !(PLOT_MODE&PL_RAISE_1)))
			s = s ";raise"
		if (pl_a == "SCAN_B")
			s = s sprintf(";graph %s;send %s;plot %s %s %s", pl_a, pl_a, pl_x, pl_y, pl_n)
		else if (pl_a != "SCAN_D")
			s = s sprintf(";graph %s;show;send %s", pl_a, pl_a)
		splot_cntl(s)
	}
	if (PLOT_MODE&PL_X11FILT) {
		s = sprintf("open,colors=%s", updating? rplot_col:splot_col)
		if (force_raise || (updating && !(PLOT_MODE&PL_RAISE_1)))
			s = s ",raise"
		plot_cntl(s)
	}

	if (!updating || ((_stype&scanType_MeshScan? _g1:NPTS) == 0 || erase_flag)) {
		if (PLOT_MODE&PL_SPLOT) {
			s = PLOT_MODE&PL_YLOG? "ylog":"-ylog"
			s = s ";" PLOT_MODE&PL_NO_DOTS? "-dots":sprintf("dots %d",PL_DOTSIZE)
			s = s ";" PLOT_MODE&PL_NO_LINES? "-lines":sprintf("lines %d", PL_LINEWID)
			s = s ";" PLOT_MODE&PL_NO_EBARS? "-ebars":"ebars"
			s = s ";" PLOT_MODE&PL_GRID? "grid":"-grid"
			if (updating && PLOT_MODE&PL_FULL_RANGE)
				s = s ";" sprintf("plotrange %g %g %s auto", _sx, _fx, YMIN)
			else
				s = s ";" sprintf("plotrange auto auto %s auto", YMIN)
			if (commanded_plot)
				s = s sprintf(";plot %s %s %s", pl_x, pl_y, pl_n)
			splot_cntl(s)
		}
		if (PLOT_MODE&(PL_X11FILT|PL_ASCII)) {
			s = "erase"
			s = s "," PLOT_MODE&PL_YLOG? "ylog":"-ylog"
			s = s "," PLOT_MODE&PL_NO_DOTS? "-dots":"dots"
			s = s "," PLOT_MODE&PL_NO_LINES? "-lines":"lines"
			s = s "," PLOT_MODE&PL_NO_EBARS? "-ebars":"ebars"
			plot_cntl(s)
			if (updating && PLOT_MODE&PL_FULL_RANGE)
				plot_range(_sx, _fx, YMIN, "auto")
			else
				plot_range("auto", "auto", YMIN, "auto")
			plot_move(0, 1, pl_t)
			plot_move(0, 2, pl_yl)
			plot_move(0, -1, sprintf("%.8s", pl_xl))
		}
	}

	if (!(PLOT_MODE&(PL_X11FILT|PL_ASCII)))
		return

	if (updating)
		plot_cntl("addpoint")

	sdata_plot(@pl_a, pl_x, pl_y, pl_n)

	if (updating) {
		if (!plot_cntl("dumbterm?"))
			plot_move(9, 2, sdata_res_r1(@pl_a,pl_x,pl_y,pl_n))
		plot_move(0, 0)
	} else {
		plot_move(-50, 0, sdata_res_s1(@pl_a,pl_x,pl_y,pl_n))
		plot_move(-50, 1, sdata_res_s2(@pl_a,pl_x,pl_y,pl_n))
		plot_move(0, 3)
	}
}'

"""

The plot style is stored in PLOT_MODE.  ``setplot`` can
be invoked with the new mode as argument or with
``+*bits*`` or ``-*bits*`` to turn individual bits on
or off.

"""

def setplot '{
	local   s, mode

	if ($# > 1) {
		eprint "Usage:  setplot  or  setplot mode|+bits|-bits"
		exit
	}
	if ($# == 1) {
		s = substr("$1", 1, 1)
		if (s == "+")
			mode = PLOT_MODE+substr("$1",2)
		else if (s ==  "-")
			mode = PLOT_MODE-substr("$1",2)
		else
			mode = $1
	} else {
		local menu[], i, spnum

		menu[++i]["title"] = "Configure How Scan Plots Are Displayed"
		menu[++i]["desc"] = "Use splot utility for plots?"
		menu[  i]["bit"] = PL_SPLOT
		menu[++i]["desc"] = "  Program name for splot (SPLOT_PROGRAM)?"
		spnum = i                        # save index number for below
		menu[  i]["svalue"] = SPLOT_PROGRAM? SPLOT_PROGRAM:"splot"
		menu[  i]["bit_and"] = PL_SPLOT
		menu[  i]["info"] = "Enter an alternate pathname for \[md]splot\[me] or to \
run \[md]splot\[me] on a remote host, enter \[md]hostname:splot\[me]."
		menu[++i]["desc"] = "Use x11filt for plots?"
		menu[  i]["bit"] = PL_X11FILT
		menu[  i]["info"] = "The x11filt is the traditional high-res display \
window for plotting data."
		menu[++i]["desc"] = "Do ASCII plots?"
		menu[  i]["bit"] = PL_ASCII
		menu[  i]["bit_not"] = PL_X11FILT
		menu[  i]["info"] = "ASCII plots are low-res depictions of the scan \
data drawn in the terminal window using standard characters."
		menu[++i]["desc"] = ""
		menu[++i]["desc"] = "Draw a background grid?"
		menu[  i]["bit"] = PL_GRID
		menu[  i]["bit_and"] = PL_SPLOT
		menu[++i]["desc"] = "Draw big dots?"
		menu[  i]["bit"] = PL_NO_DOTS
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT
		menu[  i]["bit_flip"] = 1
		menu[++i]["desc"] = " Dot size?"
		menu[  i]["list"] = "2 3 4 5 6 7 8 9 10 11 12 13 14 15"
		menu[  i]["@"] = "PL_DOTSIZE"
		menu[  i]["bit_not"] = PL_NO_DOTS
		menu[  i]["bit_and"] = PL_SPLOT
		menu[++i]["desc"] = "Connect points with lines?"
		menu[  i]["bit"] = PL_NO_LINES
		menu[  i]["bit_flip"] = 1
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT
		menu[++i]["desc"] = " Line width?"
		menu[  i]["list"] = "1 2 3 4 5 6"
		menu[  i]["@"] = "PL_LINEWID"
		menu[  i]["bit_not"] = PL_NO_LINES
		menu[  i]["bit_and"] = PL_SPLOT
		menu[++i]["desc"] = "Draw error bars?"
		menu[  i]["bit"] = PL_NO_EBARS
		menu[  i]["bit_flip"] = 1
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT
		menu[++i]["desc"] = ""
		menu[++i]["desc"] = "Do plots during scans?"
		menu[  i]["bit"] = PL_IN_SCAN
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT|PL_ASCII
		menu[++i]["desc"] = " Raise plot window to top during scans?"
		menu[  i]["bit"] = PL_RAISE_1
		menu[  i]["bit_and"] = PL_IN_SCAN
		menu[  i]["bit_or"] = PL_SPLOT|PL_X11FILT
		menu[  i]["bit_flip"] = 1
		menu[++i]["desc"] = " Auto scale x-axis during scans?"
		menu[  i]["bit"] = PL_FULL_RANGE
		menu[  i]["bit_and"] = PL_IN_SCAN
		menu[  i]["bit_or"] = PL_SPLOT|PL_X11FILT
		menu[  i]["bit_flip"] = 1
		menu[++i]["desc"] = "Do plot after scan?"
		menu[  i]["bit"] = PL_AFTER_SCAN
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT|PL_ASCII
		menu[++i]["desc"] = " Raise plot window to top at end of scan?"
		menu[  i]["bit"] = PL_RAISE_2
		menu[  i]["bit_and"] = PL_AFTER_SCAN
		menu[  i]["bit_or"] = PL_SPLOT|PL_X11FILT
		menu[  i]["bit_flip"] = 1
		menu[++i]["desc"] = ""
		menu[++i]["desc"] = "Use logarithmic y-axis?"
		menu[  i]["bit"] = PL_YLOG
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT|PL_ASCII
		menu[++i]["desc"] = "Force y-axis minimum to zero?"
		menu[  i]["bit"] = PL_YZERO
		menu[  i]["bit_not"] = PL_YLOG
		menu[  i]["bit_or"] = PL_X11FILT|PL_SPLOT|PL_ASCII
		menu[++i]["desc"] = "Use background subtraction for plots?"
		menu[  i]["bit"] = PL_BG_SUB
		menu[  i]["info"] = "Subtract a background \
calculated as a line through the beginning and end points of the scan."
		menu[++i]["desc"] = " Number of points to average at each end?"
		menu[  i]["bit_and"] = PL_BG_SUB
		menu[  i]["@"] = "bg_pts"

		mode = spec_menu(menu, PLOT_MODE, doing_startup)
		printf("\n%sPLOT_MODE is %d (0x%x).\n", mode != PLOT_MODE? "New ":"", mode, mode)

		if (menu[spnum]["updated"]) {
			global SPLOT_PROGRAM
			SPLOT_PROGRAM = menu[spnum]["svalue"]
		}
	}

	if (mode&PL_YLOG)
		mode &= ~PL_YZERO
	rdef YMIN mode&PL_YZERO? "0":"\"auto\""

	if (PLOT_MODE&PL_X11FILT && !(mode&PL_X11FILT))
		plot_cntl("kill")

	if (PLOT_MODE&PL_SPLOT && !(mode&PL_SPLOT))
		splot_cntl("kill")

	rdef _plot mode&PL_IN_SCAN? "rplot":""

	if (BG = (mode&PL_BG_SUB? 1:0))
		array SCAN_B[4096][2]

	PLOT_MODE = mode
}'

# Original data is in array SCAN_D elements PL_X and PL_Y
# The background data is put into array SCAN_B and is calculated using:
#
# y' = y - (bg_yI + bg_m * x)
#
# The constants by_yI and bg_m are calculated

# SCAN_D x y NPTS
def do_bg(arr, xel, yels, no) '{
        global BG_OXEL BG_OYELS

	redo = xel != BG_OXEL || yels != BG_OYELS || array_op("updated?", arr)
	if (no > 1 && redo) {
		local n i x0 y0 x1 y1 dx
		local cols yel ys[]
		
		BG_OXEL = xel; BG_OYELS = yels
                cols = array_op("cols",arr)
		array SCAN_B[no][cols]
		array_op("row_wise", SCAN_B, 1)
		SCAN_B = SCAN_D[0:no][]
		n = bg_pts
		if (n > no / 2)
			n = no / 2
		if (n < 1)
			n = 1
                SCAN_B[][xel] = arr[][xel]
		no_ys = split(yels, ys, ",")
                for (i = 0; i< no_ys; i++) {
                  y0 = array_op("sum",arr[:n-1][ys[i]]) / n
		  y1 = array_op("sum",arr[no-n:no-1][ys[i]]) / n
		  x0 = arr[0][xel]
		  x1 = arr[no-1][xel] 
		  dx = x1 - x0;
		  if (dx != 0) {
			bg_m = (y1 - y0) / dx;
			bg_yI = y0 - bg_m * x0;
		  } else
			bg_m = bg_yI = 0;
		  SCAN_B[][ys[i]] = arr[][ys[i]] - arr[][xel] * bg_m - bg_yI
                }
	}
}'

# Used in getscan.mac
# Note, SCAN_D will not necessarily have the correct dimensions
def scan_read(filename) '{
	return array_read(filename, SCAN_D)
}'

# Select plot colors.
# Order is bgnd:win:text:axis:symb1:symb2:symb3:...
# Colors codes may include (see "colors" help file):
#        2 blue          9 black
#        3 red          11 medium aquamarine
#        4 green        12 blue
#        5 yellow       16 light blue
#        7 magenta      47 light gray
#        8 white        49 khaki
def def_colors '
	splot_col="47:49:9:3:2:7:8:9:5:4:2"
	rplot_col="49:16:9:3:2:7:8:9:5:4:2"
'

def SHARED_SCAN_D 'shared'

if (unset("splot_col")) {
	def_colors
}

if (!(whatis("SCAN_D") & 0x10000)) {
	shared array SCAN_D[4096][COUNTERS+1]
	array_op("row_wise", SCAN_D, 1)
}
if (unset("bg_pts")) {
	bg_pts = 1
}
if (unset("PL_A")) {
	PL_X = 0
	PL_A = "SCAN_D"
	plotlist("det")
}

if (unset("PLOT_MODE")) {
	setplot (PL_IN_SCAN|PL_AFTER_SCAN|PL_X11FILT|PL_NO_EBARS|PL_RAISE_1)
}
if (unset("PL_DOTSIZE")) {
	PL_DOTSIZE = 5
}
if (unset("PL_LINEWID")) {
	PL_LINEWID = 2
}

# Do not remove this line -- it keeps the parser from waiting for an "else".
#++++ install source file:  /home/sgm/spec/macros/start.mac
#
#  @(#)start.mac	6.5  03/22/14 CSS
#
#  "spec" Release 6
#
#  Copyright (c) 1988,1989,1990,1991,1992,1997,1998,2001,2013,2014
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

def mstartup '{
	local i, menu[], modes, dnum

	menu[++i]["title"] = "General Setup"
	menu[++i]["desc"] = "Title for scan headers (TITLE)?"
	menu[  i]["@"] = "TITLE"
	menu[  i]["info"] = "The title is included in the data \
file header and in the scan headers displayed on the \
screen."

	menu[++i]["desc"] = "Command file directory list for do/qdo (DO_DIR)?"
	menu[  i]["@"] = "DO_DIR"
	menu[  i]["info"] = "The command file directory list may contain \
a single directory name or a colon-separated directory list.  If there \
is no file by the name given to the do/qdo commands in the \
current directory, each directory in the list will be checked \
for the file."

	menu[++i]["head"] = ""
	menu[++i]["desc"] = "Data file directory (DATA_DIR)?"
	menu[  i]["@"] = "DATA_DIR"
	menu[  i]["info"] = "Data files will be created in \
this directory, if it exists.  Otherwise data files \
will be created in the current working directory."

	menu[++i]["desc"] = "Data file for scans (DATAFILE)?"
	dnum = i                        # save index number for below
	menu[  i]["svalue"] = DATAFILE
	menu[  i]["info"] = "If the data file is \
\"\[md]/dev/null\[me]\" data from scans will \[md]not \
be saved\[me]."

	menu[++i]["desc"] = "Next scan number (SCAN_N)?"
	menu[  i]["value"] = SCAN_N + 1
	menu[  i]["info"] = "The current value of SCAN_N is one \
less than the value displayed for the next scan number."

	menu[++i]["head"] = ""
	menu[++i]["desc"] = "Default count time for ct and uct (COUNT)?"
	menu[  i]["@"] = "COUNT"
	menu[  i]["info"] = "The default count time is used when \
the ct and uct macros are invoked without an argument."

	menu[++i]["desc"] = "Update interval for umv, uct, etc (UPDATE)?"
	menu[  i]["list"] = "0.05 0.1 0.2 0.25 0.4 0.5"
	menu[  i]["default"] = "0.25"
	menu[  i]["@"] = "UPDATE"
	menu[  i]["info"] = "The update interval for updated \
moving and counting should be chosen carefully.  Hardware \
will be polled at this interval.  The default value is 0.25 \
seconds."

	menu[++i]["head"] = "Scan Options"

	menu[++i]["desc"] = "  Sleep (settle) time before each point (_sleep)?"
	menu[  i]["@"] = "_sleep"
	menu[  i]["info"] = "The time in seconds to sleep after moving \
but before counting at each point in scans.  The default value is zero."

	if (_upd_flg)
		modes |= 1
	menu[++i]["desc"] = "  Show updated moving and counting during scans (_upd_flg)?"
	menu[  i]["bit"] = 1
	menu[  i]["info"] = "If set and the hardware allows it, \
current motor positions will be displayed while \
motors are moving to the next scan point and current counter values will be displayed \
while counting at each scan point."

	if (_pre_chk)
		modes |= 2
	menu[++i]["desc"] = "  Do hklscan prescan limit-check loops (_pre_chk)?"
	menu[  i]["bit"] = 2
	menu[  i]["info"] = "If set, motor positions for each \
HKL point in an HKL scan are checked against software \
limits.  Only reason to disable is if you are running on a \
1980s vintage CPU and are in a hurry."

	if (_sav_geo_mot)
		modes |= 4
	menu[++i]["desc"] = "  Save motors to data file at each point for HKL scans (_sav_geo_mot)?"
	menu[  i]["bit"] = 4
	menu[  i]["info"] = sprintf("If set, positions \
of the %d geometry motors are included on each line \
of the data file for HKL scans.", _numgeo)

	modes = spec_menu(menu, modes, $1)

	if (menu[dnum]["updated"]) {
		print
		newfile_f(menu[dnum]["svalue"], menu[dnum+1]["value"] - 1, 1)
	} else if (menu[dnum+1]["updated"])
		SCAN_N = menu[dnum+1]["value"] - 1

	_upd_flg = modes&1 ? 1:0
	_set_upd
	_pre_chk = modes&2 ? 1:0
	_sav_geo_mot = modes&4 ? 1:0
}'

# Call this macro to initialize some of the macro package globals
def startup '{
	local   doing_startup

	doing_startup = 1
	print "\n\
Enter <return> for no change in the displayed parameters.\n\
The names of start-up macros that can be invoked separately\n\
are shown in parenthesis above a set of queries.\n\
Type ^C to return to command level without finishing.\n\
(Interrupting one of the specialized start-up macros will\n\
likely undo any changes entered for its associated parameters.)"
	printf("\n(newsample)")
	newsample
	DO_DIR = getsval("\nCommand file directory",DO_DIR)
	COUNT = getval("Default count time for ct and uct",COUNT)
	UPDATE = getval("Update interval for umv, uct, etc. in seconds",UPDATE)
	if (whatis("starttemp")>>16)
		printf("\n(starttemp)")
	starttemp
	printf("\n(setscans)")
	setscans
	printf("\n(setplot)")
	setplot
	if (whatis("startgeo")>>16)
		printf("\n(startgeo)")
	startgeo
	if (whatis("g_mo_d")) {
		printf("\n(setmono)")
		setmono
	} else {
		LAMBDA = getval("\nX-ray wavelength \"LAMBDA\"",LAMBDA)
	}
#       printf("\n(setslits)\n")
#       setslits
}'
def newsample '
	TITLE = getsval("\nTitle for scan headers",TITLE)
	printf("\n(newfile)")
	newfile
'

if (FRESH) {
	DATAFILE = "/dev/null"
	printf("Warning:  No open data file.  Using \"/dev/null\".\n")
	DO_DIR = "."
	UPDATE = 0.25
	TITLE = SPEC
	printf("Type \"startup\" to initialize data file, etc.\n\n")
} else
	printf("Finished standard macros.\n\n")

# Obsolete looping routine for old macros.
# Normally k is set to MOTORS, but can be set to something else, e.g., 4
def _mo_loop '{
        local s
        for (j = i, s = ""; j < i + 8 && j < k; j++)
                if (is_using_motor(mA[i])) {
                        s = s sprintf("%$1", $2)
                        if (j < i + 7)
                                s = s " "
                }
        print s
}'

