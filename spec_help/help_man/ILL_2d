.TH "ILL_2D" "hardware" "08/01/12" "ILL_2d.rst 6.1  08/01/12 CSS"
.ds HF R
.na
.hy 0
.SH NAME
ILL 2D \- ILL two\-dimensional detector
.\" spec reStructuredText documentation
.
\fP
.PP
.\" @(#)ILL_2d.rst       6.1  08/01/12  CSS
.
.\" Copyright (c) 2003,2004,2012 Certified Scientific Software
.
.\" 
.
.\" versioninfo: "ILL_2D" "hardware" "08/01/12" "ILL_2d.rst 6.1  08/01/12 CSS"
.
.SH "DESCRIPTION"
.rs
.sp
\fBspec\fP supports two\-dimensional position\-sensitive detectors
used at the ADAM and the EVA instruments at the Institut Laue Langevin (ILL)
in Grenoble, France.
The support is by way of built\-in C code in \fBspec\fP that communicates
with CSS\-supplied \fBLinux\fP kernel drivers.
The drivers catch interrupts generated by trigger signals from
the detector electronics, which also supply event addresses
on the digital input lines.
The driver decodes the event address and increments a corresponding
element of an array that accumulates the data.
There are drivers for both an ISA card (Measurement Computing CIO\-PDMA16
and compatible) and a PCI card
(Measurement Computing PCI\-DIO24 and compatible \-
added in \fBspec\fP release 5.05.01\-6).
.sp
The hardware is selected in the \fBconfig\fP file with the line:
.sp
.RS 4m
\fBPC_ILL2D = device_name  dimension  @img_sel\fP
.RE
.sp
where \fBdevice_name\fP is the device node of the driver, as in
\fB/dev/pio\fP, \fBdimension\fP is the dimension of one side
of the square array used to
collect data and \fBsel\fP is the image\-device number used
as the first argument in the
\fBimage_par()\fP and \fBimage_get()\fP functions below.
The \fBdimension\fP argument is only supported by the PCI card.
The ISA card is fixed at a 256x256 array.
For the PCI card, the dimension of the array can be any power of two
from 16 to 4,096.  The native data type for both cards is unsigned long.
.sp
When running the configuration editor, switch to  the
MCA\- and CCD\-like device configuration
screen to select the "ILL 2D Detector" as a CCD\-like device.
.sp
The CSS\-supplied kernel\-level driver
expects the external detector hardware to assert an IRQ request
on pin 1 of the external connector when data is available.
For the PCI card, the interrupt\-enable signal on pin 2 must be
pulled high.  For the ISA card, the
driver will acknowledge with a signal on pin 26.
For the PCI card, there is no acknowledgment signal.
.sp
On each interrupt, data is read from the card\(aqs input registers.
For the ISA card, the column (x) and row (y)
are taken from the A and B ports, respectively,
yielding an address into the 256x256 data array:
.RS 3m
.sp
.nf
.ft CB
x = A7 A6 A5 A4 A3 A2 A1 A0  (LSB)
y = B7 B6 B5 B4 B3 B2 B2 B0  (LSB)
.ft P
.fi
.RE
.sp
For the PCI card, the C port adds additional bits as follows:
.RS 3m
.sp
.nf
.ft CB
x = C3 C2 C1 C0 A7 A6 A5 A4 A3 A2 A1 A0  (LSB)
y = C7 C6 C5 C4 B7 B6 B5 B4 B3 B2 B2 B0  (LSB)
.ft P
.fi
.RE
.sp
When the driver is configured (via software) for less than twelve bits
per channel, the appropriate number of least significant
bits (LSB) are ignored.
.sp
When an event is recognized, the
array element at that address is incremented to indicate an event.
The driver also maintains a counter of total events and total time
of acquisition.
There is also a feature for counting events and time over an interval.
.sp
To install the drivers, change to the \fBdrivers\fP
subdirectory of the \fBspec\fP distribution.
For the ISA\-card driver, type
.sp
.RS 4m
\fB./install_pio \-b 0x300 \-i 10\fP
.RE
.sp
where the base address is chosen to match the digital I/O board\(aqs jumpers
and the IRQ is chosen not to conflict with any other devices.
Type \fBcat /proc/ioports\fP and
\fBcat /proc/interrupts\fP to see what resources are currently in use.
For the PCI\-card driver, simply type
.sp
.RS 4m
\fB./install_pio24\fP
.RE
.SH "FUNCTIONS"
.rs
.sp
The \fBimage_get()\fP functions retrieves the data from the driver.
The \fBimage_par()\fP function controls
the detector interface behavior as follows.
The \fBsel\fP parameter is the image\-device number from the \fBconfig\fP file.
.RS 0m
.HP 5m
."
\fBimage_get(sel, arr)\fP
\- 
Reads data into the array \fBarr\fP.
.HP 5m
."
\fBimage_par(sel, "clear")\fP
\- 
Clears the driver data.
.HP 5m
."
\fBimage_par(sel, "run")\fP
\- 
Starts data collection.  Memory is not cleared.
.HP 5m
."
\fBimage_par(sel, "halt")\fP
\- 
Halts data collection.
.HP 5m
."
\fBimage_par(sel, "sum")\fP
\- 
Returns the total number of counts detected since last clear.
.HP 5m
."
\fBimage_par(sel, "elapsed_time")\fP
\- 
Returns the elapsed time of the run in seconds.
.HP 5m
."
\fBimage_par(sel, "rate")\fP
\- 
Returns the count rate in counts per second since the last call of
\fBimage_par()\fP with the \fB"rate"\fP argument.
.HP 5m
."
\fBimage_par(sel, "interval_sum")\fP
\- 
returns the total number of counts since the previous \fB"rate"\fP call.
.HP 5m
."
\fBimage_par(sel, "interval_time")\fP
\- 
Returns the elapsed time since the previous \fB"rate"\fP call.
.RE
.sp
The value returned by \fB"rate"\fP is, in fact, the
ratio of the values returned by \fB"interval_sum"\fP and \fB"interval_time"\fP.
.sp
The \fB"sum"\fP, \fB"elapsed_time"\fP, \fB"interval_sum"\fP and
\fB"interval_time"\fP parameters are read from the driver no
more frequently than every 100 msec.
That is, while acquisition is active,
\fBspec\fP checks to see if it has read the parameters within the last 100 msec.
If it has, it returns the last read values.
Otherwise it reads all the values and saves them to be returned on
subsequent calls within the 100 msec window.
.SH "EXAMPLE"
.rs
.sp
The following macros show how to obtain and display
the count rate:
.RS 3m
.sp
.nf
.ft CB
# display current count rate
def rate \(aq{
    local r, t, s

    r = image_par(0, "rate")        # instantaneous rate
    t = image_par(0, "elapsed_time")
    s = image_par(0, "sum")
    printf("%6d in %s at %.2f\en", s, hms(t), r)
}\(aq
# convert seconds to hours:minutes:seconds
def hms(t) \(aq{
    if (t > 0) {
        local h, m, s, d, r

        if (h = int(t/3600))
            r = sprintf("%d:", h)
        if ((m = int(t/60) \- h*60) || r)
            r = r sprintf("%02d:", m)
        s = int(t) \- h * 3600 \- m * 60
        r = r sprintf("%02d", s)
        if (d = t \- int(t))
                r = r sprintf(".%3d", int(d*1000))
        return(r)
    }
    return("0")
}\(aq
.ft P
.fi
.RE

